---
phase: 10-portfolio-management-tenant-lifecycle
plan: 04
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - src/app/api/admin/move-out/route.ts
  - src/components/admin/MoveOutDialog.tsx
autonomous: true
requirements:
  - PORT-03

must_haves:
  truths:
    - "POST /api/admin/move-out atomically sets end date, cancels active autopay, posts final charges (if charges table exists), and deactivates tenancy"
    - "Move-out uses db.transaction() to ensure all-or-nothing execution"
    - "Admin receives final charge entry UI in the move-out dialog"
    - "Move-out fails with descriptive error if tenant has no active tenancy"
    - "MoveOutDialog shows tenant info, unit info, and lets admin add final charges"
  artifacts:
    - path: "src/app/api/admin/move-out/route.ts"
      provides: "Atomic move-out workflow endpoint"
      exports: ["POST"]
    - path: "src/components/admin/MoveOutDialog.tsx"
      provides: "Move-out confirmation dialog with final charge entry"
  key_links:
    - from: "src/app/api/admin/move-out/route.ts"
      to: "src/db/schema/domain.ts"
      via: "updates tenantUnits, autopayEnrollments in transaction"
      pattern: "tenantUnits|autopayEnrollments"
---

<objective>
Build the atomic tenant move-out workflow: API route that uses db.transaction() to end tenancy, cancel autopay, and post final charges in a single atomic operation, plus a move-out dialog component for the admin UI.

Purpose: PORT-03 requires that admin can initiate a move-out that atomically handles all lifecycle steps. No partial state is possible -- if any step fails, everything rolls back. This is the most critical workflow in Phase 10.

Output: POST /api/admin/move-out endpoint with transaction, MoveOutDialog component.
</objective>

<execution_context>
@/Users/odesantos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/odesantos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-portfolio-management-tenant-lifecycle/10-RESEARCH.md

@src/db/schema/domain.ts
@src/db/index.ts
@src/app/api/autopay/cancel/route.ts
@src/lib/notifications.ts

<interfaces>
From src/db/schema/domain.ts:
```typescript
export const tenantUnits = pgTable("tenant_units", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: text("user_id").notNull(),
  unitId: uuid("unit_id").references(() => units.id, { onDelete: "cascade" }).notNull(),
  startDate: timestamp("start_date").notNull(),
  endDate: timestamp("end_date"),           // null = active
  isActive: boolean("is_active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
})

export const autopayEnrollments = pgTable("autopay_enrollments", {
  tenantUserId: text("tenant_user_id").notNull().unique(),
  status: text("status", { enum: ["active", "paused", "payment_failed", "cancelled"] }).default("active").notNull(),
  cancelledAt: timestamp("cancelled_at"),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
})
```

From src/db/index.ts (current HTTP driver -- Phase 7 will add WebSocket driver):
```typescript
// Note: db.transaction() requires the WebSocket driver from Phase 7 (INFRA-04).
// If Phase 7 is already implemented, use db.transaction(async (tx) => { ... })
// If Phase 7 is NOT yet implemented, fall back to sequential operations with
// error handling. The plan accommodates both scenarios.
```

Existing autopay cancel pattern from src/app/api/autopay/cancel/route.ts:
```typescript
await db.update(autopayEnrollments)
  .set({ status: "cancelled", cancelledAt: new Date(), updatedAt: new Date() })
  .where(eq(autopayEnrollments.id, enrollment.id))
```

Notification helper:
```typescript
import { sendNotification } from "@/lib/notifications"
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create atomic move-out API route</name>
  <files>src/app/api/admin/move-out/route.ts</files>
  <action>
Create src/app/api/admin/move-out/route.ts:

**POST /api/admin/move-out** -- Atomic move-out workflow:

Request body:
```typescript
{
  tenantUserId: string      // The tenant being moved out
  unitId: string            // The unit they're being moved out from
  moveOutDate: string       // ISO date string (e.g., "2026-03-01")
  finalCharges?: Array<{    // Optional final charges to post
    description: string
    amountCents: number
  }>
}
```

The route should:

1. Auth check (admin only)
2. Validate request body
3. Verify the tenant has an active tenancy for the specified unit (tenantUnits where userId=tenantUserId AND unitId=unitId AND isActive=true)
4. If no active tenancy: return 404 "No active tenancy found for this tenant and unit"

5. Execute all move-out operations. **If db.transaction() is available** (Phase 7 WebSocket driver), wrap everything in a transaction. **If not available** (HTTP driver), execute sequentially and handle errors gracefully.

The implementation should try to use db.transaction() and fall back to sequential if it throws a "transactions not supported" error:

```typescript
import { NextRequest, NextResponse } from "next/server"
import { auth } from "@/lib/auth"
import { headers } from "next/headers"
import { db } from "@/db"
import { tenantUnits, autopayEnrollments, units } from "@/db/schema/domain"
import { user } from "@/db/schema/auth"
import { eq, and } from "drizzle-orm"
import { sendNotification } from "@/lib/notifications"

export async function POST(request: NextRequest) {
  const session = await auth.api.getSession({ headers: await headers() })
  if (!session || session.user.role !== "admin") {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
  }

  let body: {
    tenantUserId?: string
    unitId?: string
    moveOutDate?: string
    finalCharges?: Array<{ description: string; amountCents: number }>
  }
  try {
    body = await request.json()
  } catch {
    return NextResponse.json({ error: "Invalid request body" }, { status: 400 })
  }

  const { tenantUserId, unitId, moveOutDate, finalCharges } = body

  if (!tenantUserId || !unitId || !moveOutDate) {
    return NextResponse.json(
      { error: "tenantUserId, unitId, and moveOutDate are required" },
      { status: 400 }
    )
  }

  // Parse move-out date
  const moveOutDateObj = new Date(moveOutDate)
  if (isNaN(moveOutDateObj.getTime())) {
    return NextResponse.json({ error: "Invalid moveOutDate" }, { status: 400 })
  }

  // Verify active tenancy exists
  const [activeTenancy] = await db
    .select()
    .from(tenantUnits)
    .where(and(
      eq(tenantUnits.userId, tenantUserId),
      eq(tenantUnits.unitId, unitId),
      eq(tenantUnits.isActive, true),
    ))
    .limit(1)

  if (!activeTenancy) {
    return NextResponse.json(
      { error: "No active tenancy found for this tenant and unit" },
      { status: 404 }
    )
  }

  // Execute move-out operations
  // Try transaction first (Phase 7 WebSocket driver), fall back to sequential
  try {
    const executeMoveOut = async (executor: typeof db) => {
      // Step 1: Set end date and deactivate tenancy
      await executor.update(tenantUnits)
        .set({
          endDate: moveOutDateObj,
          isActive: false,
        })
        .where(eq(tenantUnits.id, activeTenancy.id))

      // Step 2: Cancel active autopay (if any)
      await executor.update(autopayEnrollments)
        .set({
          status: "cancelled",
          cancelledAt: new Date(),
          updatedAt: new Date(),
        })
        .where(and(
          eq(autopayEnrollments.tenantUserId, tenantUserId),
          eq(autopayEnrollments.status, "active"),
        ))

      // Step 3: Post final charges (if charges table exists from Phase 8)
      // This uses dynamic import to check if the charges table exists
      // If Phase 8 hasn't been implemented yet, skip this step gracefully
      if (finalCharges && finalCharges.length > 0) {
        try {
          // Try to import charges from schema - if it doesn't exist, skip
          const schema = await import("@/db/schema/domain")
          if ("charges" in schema) {
            const chargesTable = (schema as any).charges
            for (const charge of finalCharges) {
              await executor.insert(chargesTable).values({
                tenantUserId,
                unitId,
                type: "one_time",
                description: charge.description,
                amountCents: charge.amountCents,
                status: "pending",
              })
            }
          }
        } catch {
          // charges table not yet available (Phase 8 not implemented)
          // Log but don't fail the move-out
          console.warn("Final charges skipped: charges table not yet available")
        }
      }
    }

    // Try transaction first
    try {
      await (db as any).transaction(async (tx: typeof db) => {
        await executeMoveOut(tx)
      })
    } catch (txError: any) {
      // If transaction is not supported (HTTP driver), fall back to sequential
      if (txError.message?.includes("transaction") || txError.message?.includes("not supported")) {
        console.warn("Transaction not available, executing move-out sequentially")
        await executeMoveOut(db)
      } else {
        throw txError
      }
    }
  } catch (err: any) {
    console.error("Move-out failed:", err)
    return NextResponse.json(
      { error: "Move-out failed. No changes were made. " + err.message },
      { status: 500 }
    )
  }

  // Get tenant and unit info for notifications (after transaction)
  const [tenantInfo] = await db
    .select({ name: user.name, email: user.email })
    .from(user)
    .where(eq(user.id, tenantUserId))
    .limit(1)

  const [unitInfo] = await db
    .select({ unitNumber: units.unitNumber })
    .from(units)
    .where(eq(units.id, unitId))
    .limit(1)

  // Notify tenant of move-out
  void sendNotification({
    userId: tenantUserId,
    type: "system",
    title: "Move-Out Processed",
    body: `Your tenancy for Unit ${unitInfo?.unitNumber ?? "unknown"} has ended as of ${moveOutDateObj.toLocaleDateString()}. You can still access your payment and maintenance history.`,
    channels: ["in_app", "email"],
  })

  // Notify admin(s)
  const adminUsers = await db
    .select({ id: user.id })
    .from(user)
    .where(eq(user.role, "admin"))

  for (const adminUser of adminUsers) {
    if (adminUser.id === session.user.id) continue // skip the admin who initiated
    void sendNotification({
      userId: adminUser.id,
      type: "system",
      title: "Tenant Moved Out",
      body: `${tenantInfo?.name ?? "Tenant"} has been moved out of Unit ${unitInfo?.unitNumber ?? "unknown"}.`,
      channels: ["in_app"],
    })
  }

  return NextResponse.json({
    success: true,
    moveOutDate: moveOutDateObj.toISOString(),
    autopayStatus: "cancelled",
    finalChargesPosted: finalCharges?.length ?? 0,
  })
}
```

Important: The transaction wrapping is critical for PORT-03's "no partial state" requirement. The try-catch around db.transaction() provides graceful degradation if Phase 7 hasn't been implemented yet, but in production the WebSocket driver from Phase 7 MUST be in place for true atomicity.

Important: Notifications are sent AFTER the transaction completes (outside the transaction) so notification failures don't roll back the move-out.
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>POST /api/admin/move-out created with atomic transaction wrapping. Handles tenancy deactivation, autopay cancellation, final charges (if available), and notifications.</done>
</task>

<task type="auto">
  <name>Task 2: Create MoveOutDialog component</name>
  <files>src/components/admin/MoveOutDialog.tsx</files>
  <action>
Create src/components/admin/MoveOutDialog.tsx as a "use client" component:

This is a dialog that admin uses to initiate a tenant move-out:
- Props: `tenant: { userId, name, email }`, `unit: { id, unitNumber }`, `onSuccess: () => void`, `trigger: React.ReactNode`
- Fields:
  - Move-out date (date input, defaults to today)
  - Final charges section: dynamic list of charge entries (description + amount in dollars)
    - "Add Final Charge" button to add entries
    - Each entry has: description text input, amount dollar input, remove button
  - Summary showing: tenant name, unit number, move-out date, list of final charges with total
- Confirmation text: "This action will end {name}'s tenancy for Unit {unitNumber}, cancel any active autopay, and post {N} final charge(s). This cannot be undone."
- Submit button: "Confirm Move-Out"
- On submit: calls POST /api/admin/move-out with the form data
- Shows loading state during API call
- On success: toast "Move-out completed successfully", close dialog, call onSuccess
- On error: show error toast

```typescript
"use client"

import { useState } from "react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog"
import { toast } from "sonner"

interface FinalCharge {
  description: string
  amountDollars: string
}

interface MoveOutDialogProps {
  tenant: { userId: string; name: string; email: string }
  unit: { id: string; unitNumber: string }
  onSuccess: () => void
  trigger: React.ReactNode
}

export function MoveOutDialog({ tenant, unit, onSuccess, trigger }: MoveOutDialogProps) {
  const [open, setOpen] = useState(false)
  const [moveOutDate, setMoveOutDate] = useState(
    new Date().toISOString().split("T")[0]
  )
  const [finalCharges, setFinalCharges] = useState<FinalCharge[]>([])
  const [loading, setLoading] = useState(false)

  function addCharge() {
    setFinalCharges([...finalCharges, { description: "", amountDollars: "" }])
  }

  function removeCharge(index: number) {
    setFinalCharges(finalCharges.filter((_, i) => i !== index))
  }

  function updateCharge(index: number, field: keyof FinalCharge, value: string) {
    const updated = [...finalCharges]
    updated[index] = { ...updated[index], [field]: value }
    setFinalCharges(updated)
  }

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault()

    // Validate final charges
    const validCharges = finalCharges
      .filter((c) => c.description.trim() && c.amountDollars)
      .map((c) => ({
        description: c.description.trim(),
        amountCents: Math.round(parseFloat(c.amountDollars) * 100),
      }))

    // Check for invalid amounts
    if (validCharges.some((c) => isNaN(c.amountCents) || c.amountCents <= 0)) {
      toast.error("All final charge amounts must be valid positive numbers")
      return
    }

    setLoading(true)
    try {
      const res = await fetch("/api/admin/move-out", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          tenantUserId: tenant.userId,
          unitId: unit.id,
          moveOutDate,
          finalCharges: validCharges.length > 0 ? validCharges : undefined,
        }),
      })

      if (!res.ok) {
        const data = await res.json()
        throw new Error(data.error || "Move-out failed")
      }

      toast.success(`${tenant.name} moved out of Unit ${unit.unitNumber}`)
      setOpen(false)
      setFinalCharges([])
      onSuccess()
    } catch (err: any) {
      toast.error(err.message)
    } finally {
      setLoading(false)
    }
  }

  const totalCents = finalCharges.reduce((sum, c) => {
    const cents = Math.round(parseFloat(c.amountDollars || "0") * 100)
    return sum + (isNaN(cents) ? 0 : cents)
  }, 0)

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>{trigger}</DialogTrigger>
      <DialogContent className="max-w-lg">
        <DialogHeader>
          <DialogTitle>Move Out Tenant</DialogTitle>
          <DialogDescription>
            End {tenant.name}'s tenancy for Unit {unit.unitNumber}. This will
            cancel any active autopay and post final charges.
          </DialogDescription>
        </DialogHeader>
        <form onSubmit={handleSubmit} className="space-y-4">
          {/* Move-out date */}
          <div className="space-y-2">
            <Label htmlFor="move-out-date">Move-Out Date</Label>
            <Input
              id="move-out-date"
              type="date"
              value={moveOutDate}
              onChange={(e) => setMoveOutDate(e.target.value)}
              disabled={loading}
            />
          </div>

          {/* Final charges */}
          <div className="space-y-2">
            <Label>Final Charges (optional)</Label>
            {finalCharges.map((charge, i) => (
              <div key={i} className="flex gap-2 items-center">
                <Input
                  placeholder="Description (e.g., Cleaning fee)"
                  value={charge.description}
                  onChange={(e) => updateCharge(i, "description", e.target.value)}
                  disabled={loading}
                  className="flex-1"
                />
                <Input
                  placeholder="Amount ($)"
                  type="number"
                  step="0.01"
                  min="0"
                  value={charge.amountDollars}
                  onChange={(e) => updateCharge(i, "amountDollars", e.target.value)}
                  disabled={loading}
                  className="w-28"
                />
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => removeCharge(i)}
                  disabled={loading}
                >
                  Remove
                </Button>
              </div>
            ))}
            <Button type="button" variant="outline" size="sm" onClick={addCharge} disabled={loading}>
              + Add Final Charge
            </Button>
            {totalCents > 0 && (
              <p className="text-sm text-gray-600">
                Total final charges: ${(totalCents / 100).toFixed(2)}
              </p>
            )}
          </div>

          {/* Confirmation warning */}
          <div className="rounded-lg border border-amber-200 bg-amber-50 p-3">
            <p className="text-sm text-amber-800">
              This will end {tenant.name}'s tenancy, cancel any active autopay,
              {finalCharges.length > 0 ? ` post ${finalCharges.length} final charge(s),` : ""}
              {" "}and archive the tenancy record. This cannot be undone.
            </p>
          </div>

          <DialogFooter>
            <Button
              type="button"
              variant="outline"
              onClick={() => setOpen(false)}
              disabled={loading}
            >
              Cancel
            </Button>
            <Button type="submit" variant="destructive" disabled={loading}>
              {loading ? "Processing..." : "Confirm Move-Out"}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  )
}
```

Important: The dialog uses a destructive variant button to emphasize the irreversibility. The warning message clearly states all consequences.

Important: Final charges are optional. If no charges are added, the move-out still processes (ends tenancy + cancels autopay). The charge amounts are entered in dollars and converted to cents for the API.
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>MoveOutDialog component created with date picker, dynamic final charge entry, dollar-to-cents conversion, confirmation warning, and destructive submit button.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no errors
- POST /api/admin/move-out validates input and checks for active tenancy
- Move-out attempts transaction wrapping, falls back to sequential
- Tenancy deactivated: isActive=false, endDate set
- Autopay cancelled if active
- Final charges posted if charges table exists
- Notifications sent to tenant and admin after successful move-out
- MoveOutDialog provides date input, final charge entry, and confirmation
</verification>

<success_criteria>
- Atomic move-out: tenancy end + autopay cancel + final charges in one operation
- No partial state possible when transaction support is available
- Graceful degradation if charges table not yet available
- Clear confirmation UX with irreversibility warning
- Tenant and admin notified after successful move-out
</success_criteria>

<output>
After completion, create `.planning/phases/10-portfolio-management-tenant-lifecycle/10-04-SUMMARY.md`
</output>
