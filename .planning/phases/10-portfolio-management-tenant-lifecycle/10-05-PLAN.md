---
phase: 10-portfolio-management-tenant-lifecycle
plan: 05
type: execute
wave: 3
depends_on: ["10-03", "10-04"]
files_modified:
  - src/app/(tenant)/tenant/dashboard/page.tsx
  - src/app/(tenant)/layout.tsx
  - src/components/tenant/InviteTokenEntry.tsx
  - src/components/tenant/ReadOnlyBanner.tsx
  - src/app/api/invites/consume/route.ts
autonomous: true
requirements:
  - PORT-04
  - TUX-01

must_haves:
  truths:
    - "Moved-out tenant can log in and sees read-only dashboard with payment and maintenance history"
    - "Read-only mode hides action buttons (Pay Rent, Submit Maintenance, etc.) but shows data"
    - "Tenant with no active unit and no past units sees empty-state with invite token entry form"
    - "POST /api/invites/consume allows logged-in tenant to self-associate by entering an invite token"
    - "Invite token consumption reuses existing atomic UPDATE pattern from auth.ts"
    - "Tenant cannot consume invite token if they already have an active unit"
    - "Read-only banner clearly communicates past-tenant status"
  artifacts:
    - path: "src/app/(tenant)/tenant/dashboard/page.tsx"
      provides: "Dashboard with 3 states: active, read-only (past tenant), empty (no unit)"
    - path: "src/app/(tenant)/layout.tsx"
      provides: "Tenant layout that allows past-tenant access"
    - path: "src/components/tenant/InviteTokenEntry.tsx"
      provides: "Self-service invite token input form"
    - path: "src/components/tenant/ReadOnlyBanner.tsx"
      provides: "Banner indicating read-only access for past tenants"
    - path: "src/app/api/invites/consume/route.ts"
      provides: "Invite token consumption endpoint for logged-in tenants"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/invites/consume/route.ts"
      to: "src/lib/tokens.ts"
      via: "hashToken for token verification"
      pattern: "hashToken"
    - from: "src/app/api/invites/consume/route.ts"
      to: "src/db/schema/domain.ts"
      via: "atomic update on inviteTokens + insert tenantUnits"
      pattern: "inviteTokens|tenantUnits"
    - from: "src/app/(tenant)/tenant/dashboard/page.tsx"
      to: "src/components/tenant/InviteTokenEntry.tsx"
      via: "renders InviteTokenEntry in empty state"
      pattern: "InviteTokenEntry"
---

<objective>
Implement read-only access for moved-out tenants and self-service invite token entry for tenants with no active unit.

Purpose: PORT-04 requires moved-out tenants to retain read-only access to their history. TUX-01 requires tenants with no active unit to see an empty-state dashboard with invite token entry. These two features modify the same dashboard page and tenant layout.

Output: 3-state tenant dashboard (active, read-only, empty), invite consumption API, InviteTokenEntry component, ReadOnlyBanner component.
</objective>

<execution_context>
@/Users/odesantos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/odesantos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-portfolio-management-tenant-lifecycle/10-RESEARCH.md

@src/app/(tenant)/tenant/dashboard/page.tsx
@src/app/(tenant)/layout.tsx
@src/app/invite/[token]/page.tsx
@src/lib/auth.ts
@src/lib/tokens.ts
@src/db/schema/domain.ts

<interfaces>
From src/db/schema/domain.ts:
```typescript
export const tenantUnits = pgTable("tenant_units", {
  userId: text("user_id").notNull(),
  unitId: uuid("unit_id").references(() => units.id).notNull(),
  startDate: timestamp("start_date").notNull(),
  endDate: timestamp("end_date"),           // null = active
  isActive: boolean("is_active").default(true).notNull(),
})

export const inviteTokens = pgTable("invite_tokens", {
  unitId: uuid("unit_id").references(() => units.id).notNull(),
  tokenHash: text("token_hash").notNull().unique(),
  status: text("status", { enum: ["pending", "used", "expired"] }).default("pending").notNull(),
  usedByUserId: text("used_by_user_id"),
  expiresAt: timestamp("expires_at").notNull(),
  usedAt: timestamp("used_at"),
})
```

From src/lib/tokens.ts:
```typescript
export function hashToken(token: string): string {
  return createHash("sha256").update(token).digest("hex")
}
```

Existing invite consumption pattern from src/lib/auth.ts hooks:
```typescript
// Atomic consumption: UPDATE WHERE status='pending' AND not expired
const [consumed] = await db.update(inviteTokens)
  .set({ status: "used", usedByUserId: newSession.user.id, usedAt: now })
  .where(and(
    eq(inviteTokens.tokenHash, tokenHash),
    eq(inviteTokens.status, "pending"),
    gt(inviteTokens.expiresAt, now),
  ))
  .returning()
```

Current dashboard empty state (basic):
```typescript
if (!link) {
  return (
    <div>
      <h1 className="text-2xl font-bold text-gray-900">Dashboard</h1>
      <p className="mt-2 text-gray-600">
        Your account is not linked to a unit yet. Please contact your landlord for an invite.
      </p>
    </div>
  )
}
```

Tenant layout nav links:
```typescript
<Link href="/tenant/dashboard">Dashboard</Link>
<Link href="/tenant/payments">Payments</Link>
<Link href="/tenant/maintenance">Maintenance</Link>
<Link href="/tenant/documents">Documents</Link>
<Link href="/tenant/profile">Profile</Link>
<Link href="/tenant/notifications">Notifications</Link>
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create invite consumption API and InviteTokenEntry component</name>
  <files>src/app/api/invites/consume/route.ts, src/components/tenant/InviteTokenEntry.tsx</files>
  <action>
1. Create src/app/api/invites/consume/route.ts:

**POST /api/invites/consume** -- Consume an invite token for a logged-in tenant:

Request body: `{ token: string }` (the raw invite token, NOT the hash)

Logic:
- Auth check (any authenticated user, not admin-only)
- Validate body: token is required and non-empty
- Check if user already has an active tenancy (tenantUnits where userId=session.user.id AND isActive=true)
  - If yes: return 409 "You already have an active unit. Contact your landlord to transfer units."
- Hash the token using hashToken
- Atomically consume: UPDATE inviteTokens SET status='used', usedByUserId, usedAt WHERE tokenHash=hash AND status='pending' AND expiresAt > now
  - This is the SAME pattern used in src/lib/auth.ts hooks -- reuse it
- If no rows returned: return 400 "Invalid or expired invite code"
- Get unit info for the consumed token (unitId from the invite)
- Create tenantUnits record: insert with userId, unitId, startDate=now, isActive=true
- Get unit number for response
- Return: `{ success: true, unitNumber: "..." }`

```typescript
import { NextRequest, NextResponse } from "next/server"
import { auth } from "@/lib/auth"
import { headers } from "next/headers"
import { db } from "@/db"
import { inviteTokens, tenantUnits, units } from "@/db/schema/domain"
import { hashToken } from "@/lib/tokens"
import { eq, and, gt } from "drizzle-orm"

export async function POST(request: NextRequest) {
  const session = await auth.api.getSession({ headers: await headers() })
  if (!session) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
  }

  let body: { token?: string }
  try {
    body = await request.json()
  } catch {
    return NextResponse.json({ error: "Invalid request body" }, { status: 400 })
  }

  const { token } = body
  if (!token?.trim()) {
    return NextResponse.json({ error: "Invite code is required" }, { status: 400 })
  }

  // Check if user already has an active tenancy
  const [existingActive] = await db
    .select({ id: tenantUnits.id })
    .from(tenantUnits)
    .where(and(
      eq(tenantUnits.userId, session.user.id),
      eq(tenantUnits.isActive, true),
    ))
    .limit(1)

  if (existingActive) {
    return NextResponse.json(
      { error: "You already have an active unit. Contact your landlord to transfer units." },
      { status: 409 }
    )
  }

  // Hash and atomically consume token
  const tokenHash = hashToken(token.trim())
  const now = new Date()

  const [consumed] = await db
    .update(inviteTokens)
    .set({
      status: "used" as const,
      usedByUserId: session.user.id,
      usedAt: now,
    })
    .where(and(
      eq(inviteTokens.tokenHash, tokenHash),
      eq(inviteTokens.status, "pending"),
      gt(inviteTokens.expiresAt, now),
    ))
    .returning()

  if (!consumed) {
    return NextResponse.json(
      { error: "Invalid or expired invite code. Please check the code and try again." },
      { status: 400 }
    )
  }

  // Create tenancy link
  await db.insert(tenantUnits).values({
    userId: session.user.id,
    unitId: consumed.unitId,
    startDate: now,
    isActive: true,
  })

  // Get unit number for response
  const [unit] = await db
    .select({ unitNumber: units.unitNumber })
    .from(units)
    .where(eq(units.id, consumed.unitId))
    .limit(1)

  return NextResponse.json({
    success: true,
    unitNumber: unit?.unitNumber ?? "Unknown",
  })
}
```

2. Create src/components/tenant/InviteTokenEntry.tsx as a "use client" component:

This is the form shown on the empty-state dashboard when a tenant has no active unit:

```typescript
"use client"

import { useState } from "react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card"
import { toast } from "sonner"
import { useRouter } from "next/navigation"

export function InviteTokenEntry() {
  const [token, setToken] = useState("")
  const [loading, setLoading] = useState(false)
  const router = useRouter()

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault()
    if (!token.trim()) return

    setLoading(true)
    try {
      const res = await fetch("/api/invites/consume", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ token: token.trim() }),
      })
      const data = await res.json()
      if (!res.ok) throw new Error(data.error || "Invalid invite code")

      toast.success(`Successfully linked to Unit ${data.unitNumber}!`)
      router.refresh()
    } catch (err: any) {
      toast.error(err.message)
    } finally {
      setLoading(false)
    }
  }

  return (
    <Card className="max-w-md">
      <CardHeader>
        <CardTitle>Welcome!</CardTitle>
        <CardDescription>
          Enter the invite code from your landlord to connect your account to
          your unit and access all tenant features.
        </CardDescription>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <Input
              placeholder="Enter invite code"
              value={token}
              onChange={(e) => setToken(e.target.value)}
              disabled={loading}
              className="font-mono"
            />
            <p className="mt-1 text-xs text-gray-500">
              This code was provided in your welcome letter or by your property manager.
            </p>
          </div>
          <Button type="submit" disabled={loading || !token.trim()} className="w-full">
            {loading ? "Linking..." : "Link to Unit"}
          </Button>
        </form>
      </CardContent>
    </Card>
  )
}
```

Important: The token input uses `font-mono` class for better readability of the base64url token string. The form reuses the same atomic consumption pattern from auth.ts for race condition safety.
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>POST /api/invites/consume created with atomic token consumption, active-tenancy guard, and tenancy creation. InviteTokenEntry component provides clean form with error handling.</done>
</task>

<task type="auto">
  <name>Task 2: Update tenant dashboard for 3-state detection and read-only mode</name>
  <files>src/app/(tenant)/tenant/dashboard/page.tsx, src/components/tenant/ReadOnlyBanner.tsx, src/app/(tenant)/layout.tsx</files>
  <action>
1. Create src/components/tenant/ReadOnlyBanner.tsx:

A banner that displays at the top of the dashboard for moved-out tenants:

```typescript
import { Card, CardContent } from "@/components/ui/card"

interface ReadOnlyBannerProps {
  unitNumber: string
  endDate: Date | null
}

export function ReadOnlyBanner({ unitNumber, endDate }: ReadOnlyBannerProps) {
  return (
    <Card className="border-blue-200 bg-blue-50">
      <CardContent className="py-3 px-4">
        <p className="text-sm text-blue-800">
          <span className="font-medium">Read-only access</span> -- Your tenancy
          for Unit {unitNumber} ended
          {endDate ? ` on ${endDate.toLocaleDateString()}` : ""}.
          You can view your payment and maintenance history below.
        </p>
      </CardContent>
    </Card>
  )
}
```

2. Modify src/app/(tenant)/tenant/dashboard/page.tsx:

The dashboard needs to detect 3 states:

**State A: Active tenant** (current behavior) -- has an active tenantUnit record
- Show full dashboard with all actions (Pay Rent, Submit Maintenance, etc.)

**State B: Past tenant (moved-out)** -- has tenantUnit records but none are active (all isActive=false)
- Show ReadOnlyBanner at top
- Show payment history (read-only, no Pay Rent button)
- Show maintenance history (read-only, no Submit Request button)
- Hide autopay card
- Use the most recent past tenancy to get unitId for queries

**State C: No unit (never linked or waiting for invite)** -- no tenantUnit records at all
- Show InviteTokenEntry component
- Clean empty state with welcome message

Modify the dashboard:

```typescript
import { auth } from "@/lib/auth"
import { headers } from "next/headers"
import { db } from "@/db"
import { units, tenantUnits, payments, autopayEnrollments, maintenanceRequests, documentRequests, notifications, properties } from "@/db/schema"
import { eq, and, desc, count, isNull } from "drizzle-orm"
import { PayRentButton } from "@/components/tenant/PayRentButton"
import { PaymentSummaryCard } from "@/components/tenant/PaymentSummaryCard"
import { AutopayStatusCard } from "@/components/tenant/AutopayStatusCard"
import { DashboardMaintenance } from "@/components/tenant/DashboardMaintenance"
import { DashboardNotifications } from "@/components/tenant/DashboardNotifications"
import { InviteTokenEntry } from "@/components/tenant/InviteTokenEntry"
import { ReadOnlyBanner } from "@/components/tenant/ReadOnlyBanner"

export default async function TenantDashboard() {
  const session = await auth.api.getSession({ headers: await headers() })
  if (!session) return null

  // Check for active tenancy
  const [activeLink] = await db
    .select()
    .from(tenantUnits)
    .where(and(eq(tenantUnits.userId, session.user.id), eq(tenantUnits.isActive, true)))

  // Check for past tenancies (moved-out)
  const pastLinks = await db
    .select()
    .from(tenantUnits)
    .where(and(eq(tenantUnits.userId, session.user.id), eq(tenantUnits.isActive, false)))
    .orderBy(desc(tenantUnits.endDate))

  // STATE C: No unit at all -- show invite token entry
  if (!activeLink && pastLinks.length === 0) {
    return (
      <div className="space-y-6">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">Dashboard</h1>
          <p className="mt-2 text-gray-600">
            Welcome to the tenant portal! Link your account to your unit to get started.
          </p>
        </div>
        <InviteTokenEntry />
      </div>
    )
  }

  // Determine which link and mode to use
  const link = activeLink || pastLinks[0]  // Use active, or most recent past
  const isReadOnly = !activeLink  // Read-only if no active link

  // Get unit details
  const [unit] = await db.select().from(units).where(eq(units.id, link.unitId))

  // Get most recent payment (works for both active and past tenants)
  const [lastPayment] = await db
    .select()
    .from(payments)
    .where(and(eq(payments.tenantUserId, session.user.id), eq(payments.unitId, link.unitId)))
    .orderBy(desc(payments.createdAt))
    .limit(1)

  // Get autopay enrollment (only relevant for active tenants)
  const [enrollment] = isReadOnly
    ? [undefined]
    : await db
        .select()
        .from(autopayEnrollments)
        .where(eq(autopayEnrollments.tenantUserId, session.user.id))

  // Get recent maintenance requests
  const recentMaintenance = await db
    .select({
      id: maintenanceRequests.id,
      category: maintenanceRequests.category,
      description: maintenanceRequests.description,
      status: maintenanceRequests.status,
      createdAt: maintenanceRequests.createdAt,
    })
    .from(maintenanceRequests)
    .where(eq(maintenanceRequests.tenantUserId, session.user.id))
    .orderBy(desc(maintenanceRequests.createdAt))
    .limit(3)

  // Get pending document requests count (only for active tenants)
  const [docReqCount] = isReadOnly
    ? [{ value: 0 }]
    : await db
        .select({ value: count() })
        .from(documentRequests)
        .where(and(
          eq(documentRequests.tenantUserId, session.user.id),
          eq(documentRequests.status, "pending"),
        ))

  // Get recent notifications
  const recentNotifications = await db
    .select({
      id: notifications.id,
      title: notifications.title,
      body: notifications.body,
      type: notifications.type,
      readAt: notifications.readAt,
      createdAt: notifications.createdAt,
    })
    .from(notifications)
    .where(and(
      eq(notifications.userId, session.user.id),
      eq(notifications.channel, "in_app"),
    ))
    .orderBy(desc(notifications.createdAt))
    .limit(5)

  const [unread] = await db
    .select({ value: count() })
    .from(notifications)
    .where(and(
      eq(notifications.userId, session.user.id),
      eq(notifications.channel, "in_app"),
      isNull(notifications.readAt),
    ))

  return (
    <div className="space-y-6">
      {/* Read-only banner for past tenants */}
      {isReadOnly && (
        <ReadOnlyBanner
          unitNumber={unit?.unitNumber ?? "Unknown"}
          endDate={link.endDate}
        />
      )}

      {/* Header */}
      <div>
        <h1 className="text-2xl font-bold text-gray-900">Dashboard</h1>
        <p className="mt-1 text-gray-600">
          Unit {unit?.unitNumber}
          {isReadOnly && " (past tenancy)"}
        </p>
      </div>

      {/* TOP SECTION: Payment Status + Autopay (conditional) */}
      <div className="space-y-4">
        <PaymentSummaryCard
          rentAmountCents={unit?.rentAmountCents ?? null}
          rentDueDay={unit?.rentDueDay ?? null}
          lastPayment={lastPayment ? {
            amountCents: lastPayment.amountCents,
            status: lastPayment.status,
            paidAt: lastPayment.paidAt,
            paymentMethod: lastPayment.paymentMethod,
          } : null}
        />
        {!isReadOnly && (
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
            <AutopayStatusCard
              enrollment={enrollment ? {
                status: enrollment.status,
                paymentMethodType: enrollment.paymentMethodType,
                paymentMethodLast4: enrollment.paymentMethodLast4,
                paymentMethodBrand: enrollment.paymentMethodBrand,
                nextChargeDate: enrollment.nextChargeDate,
                enrolledAt: enrollment.enrolledAt,
              } : null}
              rentAmountCents={unit?.rentAmountCents ?? null}
            />
            <div className="flex items-stretch">
              <div className="w-full flex flex-col justify-center rounded-lg border bg-white p-4">
                <PayRentButton
                  unitId={link.unitId}
                  rentAmountCents={unit?.rentAmountCents ?? null}
                />
              </div>
            </div>
          </div>
        )}
      </div>

      {/* MIDDLE SECTION: Maintenance + Documents */}
      <DashboardMaintenance
        recentRequests={recentMaintenance}
        pendingDocumentRequests={isReadOnly ? 0 : (docReqCount?.value ?? 0)}
      />

      {/* BOTTOM SECTION: Notifications */}
      <DashboardNotifications
        recentNotifications={recentNotifications}
        unreadCount={unread?.value ?? 0}
      />
    </div>
  )
}
```

3. Update src/app/(tenant)/layout.tsx:

The tenant layout should NOT block past tenants from accessing the portal. It currently only checks for a valid session, which is correct. However, we should conditionally hide nav links that don't apply to past tenants (like Autopay).

Add a check for active tenancy in the layout to conditionally show nav links:

```typescript
import { auth } from "@/lib/auth"
import { headers } from "next/headers"
import { redirect } from "next/navigation"
import Link from "next/link"
import { NotificationBell } from "@/components/ui/NotificationBell"
import { db } from "@/db"
import { tenantUnits } from "@/db/schema"
import { eq, and } from "drizzle-orm"

export default async function TenantLayout({
  children,
}: {
  children: React.ReactNode
}) {
  const session = await auth.api.getSession({ headers: await headers() })

  if (!session) {
    redirect("/auth/login")
  }

  // Check if tenant has an active unit (for nav link visibility)
  const [activeLink] = await db
    .select({ id: tenantUnits.id })
    .from(tenantUnits)
    .where(and(eq(tenantUnits.userId, session.user.id), eq(tenantUnits.isActive, true)))
    .limit(1)

  const hasActiveUnit = !!activeLink

  return (
    <div className="min-h-screen bg-gray-50">
      <header className="bg-white border-b px-6 py-4 flex items-center justify-between">
        <span className="font-semibold text-gray-900">Tenant Portal</span>
        <div className="flex items-center gap-4">
          <NotificationBell apiUrl="/api/notifications" inboxUrl="/tenant/notifications" />
          <span className="text-sm text-gray-500">{session.user.email}</span>
        </div>
      </header>
      <nav className="bg-white border-b px-6 py-2">
        <div className="flex items-center gap-4">
          <Link href="/tenant/dashboard" className="text-sm text-gray-600 hover:text-gray-900">Dashboard</Link>
          <Link href="/tenant/payments" className="text-sm text-gray-600 hover:text-gray-900">Payments</Link>
          {hasActiveUnit && (
            <>
              <Link href="/tenant/maintenance" className="text-sm text-gray-600 hover:text-gray-900">Maintenance</Link>
              <Link href="/tenant/documents" className="text-sm text-gray-600 hover:text-gray-900">Documents</Link>
            </>
          )}
          <Link href="/tenant/profile" className="text-sm text-gray-600 hover:text-gray-900">Profile</Link>
          <Link href="/tenant/notifications" className="text-sm text-gray-600 hover:text-gray-900">Notifications</Link>
        </div>
      </nav>
      <main className="container mx-auto px-6 py-8">
        {children}
      </main>
    </div>
  )
}
```

Important: Past tenants (isReadOnly=true) can still access /tenant/payments to see their payment history. The Payments page already filters by user ID so they'll only see their own records. Maintenance and Documents links are hidden for past tenants since they can't submit new ones, but maintenance history is shown on the dashboard.

Important: The tenant layout MUST NOT block login for past tenants. The session check stays the same. Only the nav links change based on active tenancy status.
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>Dashboard updated with 3-state detection: active (full), read-only (past tenant with banner), empty (invite entry). Layout conditionally hides nav links for past tenants. Invite consumption API provides atomic self-association.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no errors
- POST /api/invites/consume validates token, checks for existing active tenancy, atomically consumes
- InviteTokenEntry component shows on empty-state dashboard
- ReadOnlyBanner shows for past tenants with clear messaging
- Active tenant dashboard unchanged (full functionality)
- Past tenant sees payment/maintenance history but no action buttons
- Tenant layout hides Maintenance/Documents nav for past tenants
- Past tenant can still access Payments page for payment history
</verification>

<success_criteria>
- Moved-out tenant logs in successfully (authentication not blocked)
- Moved-out tenant sees read-only banner and history
- Moved-out tenant cannot submit maintenance requests or pay rent
- Unlinked tenant sees invite token entry form
- Invite token consumption creates tenancy atomically (race-safe)
- Cannot consume invite if already linked to active unit
</success_criteria>

<output>
After completion, create `.planning/phases/10-portfolio-management-tenant-lifecycle/10-05-SUMMARY.md`
</output>
