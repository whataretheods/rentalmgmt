---
phase: 10-portfolio-management-tenant-lifecycle
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/admin/units/route.ts
  - src/app/api/admin/units/[id]/route.ts
autonomous: true
requirements:
  - PORT-02

must_haves:
  truths:
    - "POST /api/admin/units creates a new unit under a property with unitNumber, rentAmountCents, and rentDueDay"
    - "PUT /api/admin/units/[id] updates unit details including rent amount and due day"
    - "DELETE /api/admin/units/[id] soft-archives unit by setting archivedAt"
    - "Cannot archive a unit that has an active tenant"
    - "Cannot create a unit under an archived property"
    - "GET /api/admin/units returns units with property info, filtering out archived"
  artifacts:
    - path: "src/app/api/admin/units/route.ts"
      provides: "Unit list and create endpoints"
      exports: ["GET", "POST"]
    - path: "src/app/api/admin/units/[id]/route.ts"
      provides: "Unit update and archive endpoints"
      exports: ["PUT", "DELETE"]
  key_links:
    - from: "src/app/api/admin/units/route.ts"
      to: "src/db/schema/domain.ts"
      via: "queries and inserts units table"
      pattern: "units"
    - from: "src/app/api/admin/units/[id]/route.ts"
      to: "src/db/schema/domain.ts"
      via: "updates units table with archive check"
      pattern: "units"
---

<objective>
Create admin API routes for unit CRUD operations (list, create, edit, archive) with rent amount and due day configuration.

Purpose: PORT-02 requires admin to manage units within properties, including setting rent amounts and due days. The existing admin/units page shows units read-only with rent config forms. This plan adds full CRUD API routes.

Output: Enhanced GET + new POST on /api/admin/units, new PUT + DELETE on /api/admin/units/[id].
</objective>

<execution_context>
@/Users/odesantos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/odesantos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-portfolio-management-tenant-lifecycle/10-RESEARCH.md

@src/db/schema/domain.ts
@src/app/api/admin/units/route.ts
@src/app/api/units/[unitId]/rent-config/route.ts
@src/lib/auth.ts

<interfaces>
From src/db/schema/domain.ts (units table -- after Plan 01 adds archivedAt):
```typescript
export const units = pgTable("units", {
  id: uuid("id").primaryKey().defaultRandom(),
  propertyId: uuid("property_id").references(() => properties.id, { onDelete: "cascade" }).notNull(),
  unitNumber: text("unit_number").notNull(),
  rentAmountCents: integer("rent_amount_cents"),
  rentDueDay: integer("rent_due_day"),
  archivedAt: timestamp("archived_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
})
```

Existing src/app/api/admin/units/route.ts (currently only GET, returns all units):
```typescript
// This file will be REPLACED with enhanced GET + new POST
```

Existing rent config API at src/app/api/units/[unitId]/rent-config/route.ts:
```typescript
// PUT handler that updates rentAmountCents and rentDueDay
// This continues to work alongside the new unit CRUD routes
```

Admin auth pattern:
```typescript
const session = await auth.api.getSession({ headers: await headers() })
if (!session || session.user.role !== "admin") {
  return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance unit list API and add unit create endpoint</name>
  <files>src/app/api/admin/units/route.ts</files>
  <action>
Replace the existing src/app/api/admin/units/route.ts with enhanced GET and new POST handlers:

**GET /api/admin/units** -- List all active (non-archived) units with property info and tenant status:
- Auth check (admin only)
- Query units with LEFT JOIN to properties for property name/address
- LEFT JOIN to tenantUnits to get current tenant info (isActive=true)
- Filter: units.archivedAt IS NULL AND properties.archivedAt IS NULL
- Order by property name, then unit number
- Optional query parameter `?propertyId=xxx` to filter by property
- Return array with: id, unitNumber, propertyId, propertyName, rentAmountCents, rentDueDay, currentTenantUserId (if any), createdAt

```typescript
import { NextRequest, NextResponse } from "next/server"
import { auth } from "@/lib/auth"
import { headers } from "next/headers"
import { db } from "@/db"
import { properties, units, tenantUnits } from "@/db/schema/domain"
import { user } from "@/db/schema/auth"
import { eq, and, isNull, sql } from "drizzle-orm"

export async function GET(request: NextRequest) {
  const session = await auth.api.getSession({ headers: await headers() })
  if (!session || session.user.role !== "admin") {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
  }

  const propertyId = request.nextUrl.searchParams.get("propertyId")

  const conditions = [isNull(units.archivedAt), isNull(properties.archivedAt)]
  if (propertyId) {
    conditions.push(eq(units.propertyId, propertyId))
  }

  const result = await db
    .select({
      id: units.id,
      unitNumber: units.unitNumber,
      propertyId: units.propertyId,
      propertyName: properties.name,
      propertyAddress: properties.address,
      rentAmountCents: units.rentAmountCents,
      rentDueDay: units.rentDueDay,
      createdAt: units.createdAt,
      currentTenantName: user.name,
      currentTenantEmail: user.email,
    })
    .from(units)
    .innerJoin(properties, eq(units.propertyId, properties.id))
    .leftJoin(
      tenantUnits,
      and(eq(tenantUnits.unitId, units.id), eq(tenantUnits.isActive, true))
    )
    .leftJoin(user, eq(tenantUnits.userId, user.id))
    .where(and(...conditions))
    .orderBy(properties.name, units.unitNumber)

  return NextResponse.json(result)
}
```

**POST /api/admin/units** -- Create a new unit:
- Auth check (admin only)
- Validate body: propertyId (required uuid), unitNumber (required non-empty string), rentAmountCents (optional integer >= 0), rentDueDay (optional integer 1-28)
- Verify the target property exists AND is not archived
- Insert into units table
- Return created unit

```typescript
export async function POST(request: NextRequest) {
  const session = await auth.api.getSession({ headers: await headers() })
  if (!session || session.user.role !== "admin") {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
  }

  let body: { propertyId?: string; unitNumber?: string; rentAmountCents?: number; rentDueDay?: number }
  try {
    body = await request.json()
  } catch {
    return NextResponse.json({ error: "Invalid request body" }, { status: 400 })
  }

  const { propertyId, unitNumber, rentAmountCents, rentDueDay } = body

  if (!propertyId || !unitNumber?.trim()) {
    return NextResponse.json({ error: "propertyId and unitNumber are required" }, { status: 400 })
  }

  if (rentDueDay !== undefined && rentDueDay !== null && (rentDueDay < 1 || rentDueDay > 28)) {
    return NextResponse.json({ error: "rentDueDay must be between 1 and 28" }, { status: 400 })
  }

  if (rentAmountCents !== undefined && rentAmountCents !== null && rentAmountCents < 0) {
    return NextResponse.json({ error: "rentAmountCents cannot be negative" }, { status: 400 })
  }

  // Verify property exists and is not archived
  const [property] = await db
    .select({ id: properties.id })
    .from(properties)
    .where(and(eq(properties.id, propertyId), isNull(properties.archivedAt)))
    .limit(1)

  if (!property) {
    return NextResponse.json({ error: "Property not found or archived" }, { status: 404 })
  }

  const [unit] = await db.insert(units).values({
    propertyId,
    unitNumber: unitNumber.trim(),
    rentAmountCents: rentAmountCents ?? null,
    rentDueDay: rentDueDay ?? null,
  }).returning()

  return NextResponse.json(unit, { status: 201 })
}
```

Important: The existing rent-config route at /api/units/[unitId]/rent-config continues to work for inline rent updates. The new POST endpoint allows creating a unit with rent pre-configured. Both approaches are valid and complement each other.
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>GET /api/admin/units enhanced with archived filtering, property info, and tenant status. POST /api/admin/units creates new units with validation.</done>
</task>

<task type="auto">
  <name>Task 2: Create unit update and archive API routes</name>
  <files>src/app/api/admin/units/[id]/route.ts</files>
  <action>
Create src/app/api/admin/units/[id]/route.ts with PUT and DELETE handlers:

**PUT /api/admin/units/[id]** -- Update a unit:
- Auth check (admin only)
- Validate body: at least one of unitNumber, rentAmountCents, rentDueDay provided
- rentDueDay must be 1-28 if provided
- rentAmountCents must be >= 0 if provided
- Update WHERE id = param AND archivedAt IS NULL
- Return updated unit or 404

**DELETE /api/admin/units/[id]** -- Archive (soft-delete) a unit:
- Auth check (admin only)
- Check if the unit has an active tenant (tenantUnits where isActive=true and unitId matches)
- If active tenant exists: return 409 Conflict with "Cannot archive unit with active tenant. Move out the tenant first."
- Otherwise: set archivedAt = new Date() and updatedAt = new Date()
- Return success

```typescript
import { NextRequest, NextResponse } from "next/server"
import { auth } from "@/lib/auth"
import { headers } from "next/headers"
import { db } from "@/db"
import { units, tenantUnits } from "@/db/schema/domain"
import { eq, and, isNull } from "drizzle-orm"

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const session = await auth.api.getSession({ headers: await headers() })
  if (!session || session.user.role !== "admin") {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
  }

  const { id } = await params
  let body: { unitNumber?: string; rentAmountCents?: number; rentDueDay?: number }
  try {
    body = await request.json()
  } catch {
    return NextResponse.json({ error: "Invalid request body" }, { status: 400 })
  }

  if (body.rentDueDay !== undefined && body.rentDueDay !== null && (body.rentDueDay < 1 || body.rentDueDay > 28)) {
    return NextResponse.json({ error: "rentDueDay must be between 1 and 28" }, { status: 400 })
  }

  if (body.rentAmountCents !== undefined && body.rentAmountCents !== null && body.rentAmountCents < 0) {
    return NextResponse.json({ error: "rentAmountCents cannot be negative" }, { status: 400 })
  }

  const updates: Record<string, unknown> = { updatedAt: new Date() }
  if (body.unitNumber?.trim()) updates.unitNumber = body.unitNumber.trim()
  if (body.rentAmountCents !== undefined) updates.rentAmountCents = body.rentAmountCents
  if (body.rentDueDay !== undefined) updates.rentDueDay = body.rentDueDay

  const [updated] = await db.update(units)
    .set(updates)
    .where(and(eq(units.id, id), isNull(units.archivedAt)))
    .returning()

  if (!updated) {
    return NextResponse.json({ error: "Unit not found or archived" }, { status: 404 })
  }

  return NextResponse.json(updated)
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const session = await auth.api.getSession({ headers: await headers() })
  if (!session || session.user.role !== "admin") {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
  }

  const { id } = await params

  // Check for active tenant in this unit
  const [activeTenant] = await db
    .select({ id: tenantUnits.id })
    .from(tenantUnits)
    .where(and(
      eq(tenantUnits.unitId, id),
      eq(tenantUnits.isActive, true),
    ))
    .limit(1)

  if (activeTenant) {
    return NextResponse.json(
      { error: "Cannot archive unit with active tenant. Move out the tenant first." },
      { status: 409 }
    )
  }

  const [archived] = await db.update(units)
    .set({ archivedAt: new Date(), updatedAt: new Date() })
    .where(and(eq(units.id, id), isNull(units.archivedAt)))
    .returning()

  if (!archived) {
    return NextResponse.json({ error: "Unit not found or already archived" }, { status: 404 })
  }

  return NextResponse.json({ success: true })
}
```

Important: The DELETE endpoint checks for active tenants using the tenantUnits table. An active tenant (isActive=true) blocks archiving. Past tenants (isActive=false) do not block archiving since their tenancy has already ended.
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>PUT /api/admin/units/[id] updates unit details with validation. DELETE /api/admin/units/[id] soft-archives with active-tenant guard.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no errors
- GET /api/admin/units returns active units with property info and tenant status
- POST /api/admin/units creates units with validation (propertyId must exist and not be archived)
- PUT /api/admin/units/[id] updates unit details with rent validation
- DELETE /api/admin/units/[id] checks for active tenants before archiving
- All routes are admin-only authenticated
</verification>

<success_criteria>
- Full unit CRUD via API routes
- Rent amount (cents) and due day (1-28) configurable on create and update
- Cannot archive unit with active tenant (409 error)
- Cannot create unit under archived property (404 error)
- Soft-delete pattern used consistently
</success_criteria>

<output>
After completion, create `.planning/phases/10-portfolio-management-tenant-lifecycle/10-02-SUMMARY.md`
</output>
