---
phase: 10-portfolio-management-tenant-lifecycle
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema/domain.ts
  - src/app/api/admin/properties/route.ts
  - src/app/api/admin/properties/[id]/route.ts
autonomous: true
requirements:
  - PORT-01

must_haves:
  truths:
    - "properties table has archivedAt column for soft-delete"
    - "GET /api/admin/properties returns active properties (excludes archived)"
    - "POST /api/admin/properties creates a new property"
    - "PUT /api/admin/properties/[id] updates property name and address"
    - "DELETE /api/admin/properties/[id] soft-deletes by setting archivedAt (not hard delete)"
    - "Cannot archive a property that has active (non-archived) units with active tenants"
  artifacts:
    - path: "src/db/schema/domain.ts"
      provides: "properties table with archivedAt column"
      contains: "archivedAt"
    - path: "src/app/api/admin/properties/route.ts"
      provides: "Property list and create endpoints"
      exports: ["GET", "POST"]
    - path: "src/app/api/admin/properties/[id]/route.ts"
      provides: "Property update and archive endpoints"
      exports: ["PUT", "DELETE"]
  key_links:
    - from: "src/app/api/admin/properties/route.ts"
      to: "src/db/schema/domain.ts"
      via: "queries and inserts properties table"
      pattern: "properties"
    - from: "src/app/api/admin/properties/[id]/route.ts"
      to: "src/db/schema/domain.ts"
      via: "updates properties table"
      pattern: "properties"
---

<objective>
Add archivedAt column to the properties table schema and create admin API routes for property CRUD operations (list, create, edit, archive).

Purpose: PORT-01 requires admin to manage properties from the dashboard. The schema change adds soft-delete support (archivedAt column) per INFRA-05 decision. The API routes provide the backend for the admin properties page.

Output: Updated properties schema with archivedAt, 4 API endpoints for property management.
</objective>

<execution_context>
@/Users/odesantos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/odesantos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-portfolio-management-tenant-lifecycle/10-RESEARCH.md

@src/db/schema/domain.ts
@src/app/api/admin/units/route.ts
@src/lib/auth.ts

<interfaces>
From src/db/schema/domain.ts (existing properties table):
```typescript
export const properties = pgTable("properties", {
  id: uuid("id").primaryKey().defaultRandom(),
  name: text("name").notNull(),
  address: text("address").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
})
```

Admin auth pattern from existing routes:
```typescript
const session = await auth.api.getSession({ headers: await headers() })
if (!session || session.user.role !== "admin") {
  return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
}
```

tenantUnits table (for checking active tenants before archive):
```typescript
export const tenantUnits = pgTable("tenant_units", {
  userId: text("user_id").notNull(),
  unitId: uuid("unit_id").references(() => units.id, { onDelete: "cascade" }).notNull(),
  isActive: boolean("is_active").default(true).notNull(),
})
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add archivedAt column to properties and units schema</name>
  <files>src/db/schema/domain.ts</files>
  <action>
Modify the existing `properties` table in src/db/schema/domain.ts to add an `archivedAt` column:

1. Add `archivedAt` to the `properties` table definition, right before `createdAt`:

```typescript
export const properties = pgTable("properties", {
  id: uuid("id").primaryKey().defaultRandom(),
  name: text("name").notNull(),
  address: text("address").notNull(),
  archivedAt: timestamp("archived_at"),  // null = active, set = archived (soft-delete)
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
})
```

2. Also add `archivedAt` to the `units` table definition, right before `createdAt`:

```typescript
export const units = pgTable("units", {
  id: uuid("id").primaryKey().defaultRandom(),
  propertyId: uuid("property_id")
    .references(() => properties.id, { onDelete: "cascade" })
    .notNull(),
  unitNumber: text("unit_number").notNull(),
  rentAmountCents: integer("rent_amount_cents"),
  rentDueDay: integer("rent_due_day"),
  archivedAt: timestamp("archived_at"),  // null = active, set = archived (soft-delete)
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
})
```

3. Push the schema to the database:
```bash
cd /Users/odesantos/Documents/rentalmgmt && npx drizzle-kit push
```

Important: The `archivedAt` column is nullable. Null means active; a timestamp means archived. This is the soft-delete pattern chosen per INFRA-05. Note: The `onDelete: "cascade"` on units.propertyId will be changed to RESTRICT in Phase 7, but for now keep as-is since Phase 7 hasn't been implemented yet.
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && npx tsc --noEmit 2>&1 | head -10 && node -e "const s = require('fs').readFileSync('src/db/schema/domain.ts','utf8'); const propsOk = s.includes('archived_at') && s.includes('archivedAt'); console.log('archivedAt in schema:', propsOk); if (!propsOk) process.exit(1)"</automated>
  </verify>
  <done>archivedAt column added to both properties and units tables in domain.ts. Schema pushed to database.</done>
</task>

<task type="auto">
  <name>Task 2: Create property CRUD API routes</name>
  <files>src/app/api/admin/properties/route.ts, src/app/api/admin/properties/[id]/route.ts</files>
  <action>
1. Create src/app/api/admin/properties/route.ts with GET and POST handlers:

**GET /api/admin/properties** -- List all active (non-archived) properties:
- Auth check (admin only)
- Query properties WHERE archivedAt IS NULL, ordered by name
- For each property, include a count of active (non-archived) units
- Return array of properties with unit counts

```typescript
import { NextRequest, NextResponse } from "next/server"
import { auth } from "@/lib/auth"
import { headers } from "next/headers"
import { db } from "@/db"
import { properties, units } from "@/db/schema/domain"
import { eq, isNull, count, sql } from "drizzle-orm"

export async function GET() {
  const session = await auth.api.getSession({ headers: await headers() })
  if (!session || session.user.role !== "admin") {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
  }

  const result = await db
    .select({
      id: properties.id,
      name: properties.name,
      address: properties.address,
      createdAt: properties.createdAt,
      updatedAt: properties.updatedAt,
      unitCount: count(units.id),
    })
    .from(properties)
    .leftJoin(units, sql`${units.propertyId} = ${properties.id} AND ${units.archivedAt} IS NULL`)
    .where(isNull(properties.archivedAt))
    .groupBy(properties.id)
    .orderBy(properties.name)

  return NextResponse.json(result)
}
```

**POST /api/admin/properties** -- Create a new property:
- Auth check (admin only)
- Validate body: name (required, non-empty string), address (required, non-empty string)
- Insert into properties table
- Return created property

```typescript
export async function POST(request: NextRequest) {
  const session = await auth.api.getSession({ headers: await headers() })
  if (!session || session.user.role !== "admin") {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
  }

  let body: { name?: string; address?: string }
  try {
    body = await request.json()
  } catch {
    return NextResponse.json({ error: "Invalid request body" }, { status: 400 })
  }

  const { name, address } = body
  if (!name?.trim() || !address?.trim()) {
    return NextResponse.json({ error: "Name and address are required" }, { status: 400 })
  }

  const [property] = await db.insert(properties).values({
    name: name.trim(),
    address: address.trim(),
  }).returning()

  return NextResponse.json(property, { status: 201 })
}
```

2. Create src/app/api/admin/properties/[id]/route.ts with PUT and DELETE handlers:

**PUT /api/admin/properties/[id]** -- Update a property:
- Auth check (admin only)
- Validate body: at least name or address provided
- Update WHERE id = param AND archivedAt IS NULL (can't edit archived properties)
- Return updated property or 404

**DELETE /api/admin/properties/[id]** -- Archive (soft-delete) a property:
- Auth check (admin only)
- Before archiving, check if the property has any units with active tenants (tenantUnits where isActive=true and the unit belongs to this property)
- If active tenants exist: return 409 Conflict with error message "Cannot archive property with active tenants. Move out all tenants first."
- Otherwise: set archivedAt = new Date() and updatedAt = new Date()
- Return success

```typescript
import { NextRequest, NextResponse } from "next/server"
import { auth } from "@/lib/auth"
import { headers } from "next/headers"
import { db } from "@/db"
import { properties, units, tenantUnits } from "@/db/schema/domain"
import { eq, and, isNull } from "drizzle-orm"

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const session = await auth.api.getSession({ headers: await headers() })
  if (!session || session.user.role !== "admin") {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
  }

  const { id } = await params
  let body: { name?: string; address?: string }
  try {
    body = await request.json()
  } catch {
    return NextResponse.json({ error: "Invalid request body" }, { status: 400 })
  }

  const updates: Record<string, unknown> = { updatedAt: new Date() }
  if (body.name?.trim()) updates.name = body.name.trim()
  if (body.address?.trim()) updates.address = body.address.trim()

  const [updated] = await db.update(properties)
    .set(updates)
    .where(and(eq(properties.id, id), isNull(properties.archivedAt)))
    .returning()

  if (!updated) {
    return NextResponse.json({ error: "Property not found" }, { status: 404 })
  }

  return NextResponse.json(updated)
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const session = await auth.api.getSession({ headers: await headers() })
  if (!session || session.user.role !== "admin") {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
  }

  const { id } = await params

  // Check for active tenants in this property's units
  const activeTenants = await db
    .select({ id: tenantUnits.id })
    .from(tenantUnits)
    .innerJoin(units, eq(tenantUnits.unitId, units.id))
    .where(and(
      eq(units.propertyId, id),
      eq(tenantUnits.isActive, true),
      isNull(units.archivedAt),
    ))
    .limit(1)

  if (activeTenants.length > 0) {
    return NextResponse.json(
      { error: "Cannot archive property with active tenants. Move out all tenants first." },
      { status: 409 }
    )
  }

  const [archived] = await db.update(properties)
    .set({ archivedAt: new Date(), updatedAt: new Date() })
    .where(and(eq(properties.id, id), isNull(properties.archivedAt)))
    .returning()

  if (!archived) {
    return NextResponse.json({ error: "Property not found or already archived" }, { status: 404 })
  }

  return NextResponse.json({ success: true })
}
```

Important: The DELETE endpoint performs a soft-delete (sets archivedAt) rather than a hard delete. This preserves all related financial and maintenance history. The check for active tenants prevents accidental disruption to current tenants.
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>Property CRUD API routes created: GET lists active properties with unit counts, POST creates new properties, PUT updates properties, DELETE soft-archives with active-tenant guard.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no errors
- properties table schema includes archivedAt column
- units table schema includes archivedAt column
- GET /api/admin/properties filters out archived properties
- POST /api/admin/properties creates with validation
- PUT /api/admin/properties/[id] updates only active properties
- DELETE /api/admin/properties/[id] checks for active tenants before archiving
</verification>

<success_criteria>
- archivedAt column exists in both properties and units tables
- All property API routes are admin-only authenticated
- Archiving a property with active tenants returns 409 error
- Soft-delete pattern used (no hard deletes)
- TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/10-portfolio-management-tenant-lifecycle/10-01-SUMMARY.md`
</output>
