---
phase: 12-vendor-work-order-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema/domain.ts
  - src/lib/vendor-notifications.ts
autonomous: true
requirements:
  - OPS-01
  - OPS-02
  - OPS-03
  - OPS-04

must_haves:
  truths:
    - "vendors, workOrders, and workOrderCosts tables exist in the database schema"
    - "Vendor notification helper can send email and SMS to a vendor contact without requiring a user account"
    - "Database migration applies cleanly with no schema conflicts"
  artifacts:
    - path: "src/db/schema/domain.ts"
      provides: "Three new table definitions for Phase 12"
      contains: "vendors"
    - path: "src/db/schema/domain.ts"
      provides: "Work order table linking vendors to maintenance requests"
      contains: "workOrders"
    - path: "src/db/schema/domain.ts"
      provides: "Work order cost line items"
      contains: "workOrderCosts"
    - path: "src/lib/vendor-notifications.ts"
      provides: "Email and SMS dispatch for vendor notifications"
      exports: ["notifyVendorAssignment"]
  key_links:
    - from: "src/db/schema/domain.ts"
      to: "maintenanceRequests table"
      via: "workOrders.maintenanceRequestId references maintenanceRequests.id"
      pattern: "references.*maintenanceRequests\\.id"
    - from: "src/db/schema/domain.ts"
      to: "vendors table"
      via: "workOrders.vendorId references vendors.id"
      pattern: "references.*vendors\\.id"
    - from: "src/db/schema/domain.ts"
      to: "workOrders table"
      via: "workOrderCosts.workOrderId references workOrders.id"
      pattern: "references.*workOrders\\.id"
---

<objective>
Create all Phase 12 database schemas (vendors, workOrders, workOrderCosts) and the vendor notification helper for sending email/SMS directly to vendors without user accounts.

Purpose: Every other plan in Phase 12 depends on these schemas and the notification helper. This plan creates the foundational data layer that Plans 02-05 build on.

Output: Three new tables defined in domain.ts, vendor notification helper (src/lib/vendor-notifications.ts), database migration applied.
</objective>

<execution_context>
@/Users/odesantos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/odesantos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-vendor-work-order-management/12-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/db/schema/domain.ts (existing tables to reference):
```typescript
export const maintenanceRequests = pgTable("maintenance_requests", {
  id: uuid("id").primaryKey().defaultRandom(),
  tenantUserId: text("tenant_user_id").notNull(),
  unitId: uuid("unit_id").references(() => units.id, { onDelete: "cascade" }).notNull(),
  category: text("category", { enum: [...] }).notNull(),
  description: text("description").notNull(),
  status: text("status", { enum: ["submitted", "acknowledged", "in_progress", "resolved"] }).default("submitted").notNull(),
  // ...timestamps
})

export const maintenancePhotos = pgTable("maintenance_photos", {
  id: uuid("id").primaryKey().defaultRandom(),
  requestId: uuid("request_id").references(() => maintenanceRequests.id, { onDelete: "cascade" }).notNull(),
  filePath: text("file_path").notNull(),
  fileName: text("file_name").notNull(),
  fileSize: integer("file_size").notNull(),
  mimeType: text("mime_type").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
})
```

From src/lib/resend.ts:
```typescript
export const resend = new Proxy({} as Resend, { ... })
// Usage: resend.emails.send({ from, to, subject, html })
```

From src/lib/twilio.ts:
```typescript
export function getTwilioClient(): ReturnType<typeof Twilio>
// Usage: getTwilioClient().messages.create({ messagingServiceSid, to, body })
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add vendors, workOrders, and workOrderCosts tables to domain schema</name>
  <files>
    src/db/schema/domain.ts
  </files>
  <action>
Append ALL Phase 12 tables to src/db/schema/domain.ts AFTER the existing `autopayEnrollments` table. Do NOT modify any existing tables.

Add a section comment: `// ==================== Phase 12: Vendor & Work Order Management ====================`

Add these three tables:

```typescript
// Vendor directory
export const vendors = pgTable("vendors", {
  id: uuid("id").primaryKey().defaultRandom(),
  companyName: text("company_name").notNull(),
  contactName: text("contact_name"),
  email: text("email"),
  phone: text("phone"),
  specialty: text("specialty", {
    enum: ["plumbing", "electrical", "hvac", "appliance", "pest_control",
           "general_maintenance", "painting", "cleaning", "landscaping", "other"],
  }),
  notes: text("notes"),
  status: text("status", { enum: ["active", "inactive"] }).default("active").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
})

// Work orders linking vendors to maintenance requests
export const workOrders = pgTable("work_orders", {
  id: uuid("id").primaryKey().defaultRandom(),
  maintenanceRequestId: uuid("maintenance_request_id")
    .references(() => maintenanceRequests.id, { onDelete: "restrict" })
    .notNull(),
  vendorId: uuid("vendor_id")
    .references(() => vendors.id, { onDelete: "set null" }),
  assignedByUserId: text("assigned_by_user_id").notNull(),
  status: text("status", {
    enum: ["assigned", "scheduled", "in_progress", "completed", "cancelled"],
  }).default("assigned").notNull(),
  priority: text("priority", {
    enum: ["low", "medium", "high", "emergency"],
  }).default("medium").notNull(),
  scheduledDate: timestamp("scheduled_date"),
  completedDate: timestamp("completed_date"),
  notes: text("notes"),
  vendorAccessToken: text("vendor_access_token").unique(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
})

// Cost line items on work orders
export const workOrderCosts = pgTable("work_order_costs", {
  id: uuid("id").primaryKey().defaultRandom(),
  workOrderId: uuid("work_order_id")
    .references(() => workOrders.id, { onDelete: "cascade" })
    .notNull(),
  description: text("description").notNull(),
  amountCents: integer("amount_cents").notNull(),
  category: text("category", {
    enum: ["labor", "materials", "permits", "other"],
  }).notNull(),
  receiptPath: text("receipt_path"),  // S3 key for receipt upload (Phase 7)
  createdAt: timestamp("created_at").defaultNow().notNull(),
})
```

CRITICAL NOTES:
- workOrders.maintenanceRequestId uses `onDelete: "restrict"` -- cannot delete a maintenance request that has work orders
- workOrders.vendorId uses `onDelete: "set null"` -- deleting a vendor does NOT remove work order history
- workOrders.vendorAccessToken has `.unique()` constraint for magic link lookup
- All user ID fields use `text()` matching Better Auth user.id type
- workOrderCosts.receiptPath is nullable (receipt upload optional, will use S3 from Phase 7)

After adding tables, generate and apply migration:
```bash
cd /Users/odesantos/Documents/rentalmgmt
npm run db:generate
npm run db:push
```
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && npx tsx -e "import('./src/db/schema/domain.ts').then(m => { const tables = ['vendors','workOrders','workOrderCosts']; tables.forEach(t => console.log(t + ':', typeof (m as any)[t])); })" 2>&1</automated>
  </verify>
  <done>
    Three new tables defined in domain.ts: vendors (with specialty enum, active/inactive status), workOrders (linking vendors to maintenance requests via FKs, with vendorAccessToken for magic links), workOrderCosts (with category enum and optional receiptPath). Database migration applied cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create vendor notification helper for email and SMS dispatch</name>
  <files>
    src/lib/vendor-notifications.ts
  </files>
  <action>
Create src/lib/vendor-notifications.ts. This helper sends email and SMS directly to vendor contact info WITHOUT using the sendNotification() helper (which requires a userId and creates in-app notification records -- vendors have no user accounts).

```typescript
import { resend } from "@/lib/resend"
import { getTwilioClient } from "@/lib/twilio"

interface VendorContact {
  email: string | null
  phone: string | null
  companyName: string
}

/**
 * Notify a vendor that they have been assigned to a work order.
 * Sends email and/or SMS directly (fire-and-forget).
 * Vendors have no user accounts, so we cannot use sendNotification().
 */
export async function notifyVendorAssignment(
  vendor: VendorContact,
  workOrderUrl: string,
  requestSummary: string
): Promise<void> {
  const emailFrom = process.env.EMAIL_FROM || "RentalMgmt <noreply@rentalmgmt.com>"

  // Email notification (if vendor has email)
  if (vendor.email) {
    void resend.emails.send({
      from: emailFrom,
      to: vendor.email,
      subject: "New Work Order Assignment - RentalMgmt",
      html: `
        <h2>New Work Order Assignment</h2>
        <p>Hello ${vendor.companyName},</p>
        <p>You have been assigned a new work order:</p>
        <p><strong>${requestSummary}</strong></p>
        <p><a href="${workOrderUrl}" style="display:inline-block;padding:10px 20px;background:#2563eb;color:#fff;text-decoration:none;border-radius:6px;">View Work Order Details</a></p>
        <p style="color:#6b7280;font-size:0.875rem;">This link provides access to the work order details. No login required.</p>
      `,
    })
  }

  // SMS notification (if vendor has phone)
  if (vendor.phone) {
    void getTwilioClient().messages.create({
      messagingServiceSid: process.env.TWILIO_MESSAGING_SERVICE_SID!,
      to: vendor.phone,
      body: `RentalMgmt: New work order assigned - ${requestSummary}. View details: ${workOrderUrl}`,
    })
  }
}
```

CRITICAL: Both email and SMS are fire-and-forget (void). Do NOT await them -- this matches the existing pattern in src/lib/notifications.ts.
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && npx tsx -e "import('./src/lib/vendor-notifications.ts').then(m => { console.log('notifyVendorAssignment:', typeof m.notifyVendorAssignment); })" 2>&1</automated>
  </verify>
  <done>
    src/lib/vendor-notifications.ts exports notifyVendorAssignment function. Accepts VendorContact (email, phone, companyName), workOrderUrl, and requestSummary. Sends email via Resend and SMS via Twilio directly -- fire-and-forget, no user account required.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npm run build` passes with no TypeScript errors
2. src/db/schema/domain.ts contains vendors, workOrders, workOrderCosts tables
3. workOrders has vendorAccessToken column with unique constraint
4. workOrders.vendorId uses onDelete: "set null" (not cascade)
5. workOrders.maintenanceRequestId uses onDelete: "restrict"
6. src/lib/vendor-notifications.ts exports notifyVendorAssignment
7. Database migration applied (all 3 new tables exist)
</verification>

<success_criteria>
- Three new database tables defined with correct column types and relationships
- Vendor notification helper sends email/SMS without requiring user accounts
- No modifications to existing tables
- npm run build passes
</success_criteria>

<output>
After completion, create `.planning/phases/12-vendor-work-order-management/12-01-SUMMARY.md`
</output>
