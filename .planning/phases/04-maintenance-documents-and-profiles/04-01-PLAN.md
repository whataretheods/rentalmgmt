---
phase: 04-maintenance-documents-and-profiles
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema/domain.ts
  - src/db/schema/index.ts
  - src/lib/uploads.ts
  - src/app/api/uploads/[...path]/route.ts
  - uploads/.gitkeep
  - .gitignore
  - package.json
autonomous: true
requirements:
  - MAINT-01
  - MAINT-02
  - MAINT-03
  - DOC-01
  - DOC-02
  - TMGMT-01

must_haves:
  truths:
    - "maintenanceRequests, maintenancePhotos, maintenanceComments, documents, documentRequests, and emergencyContacts tables exist in the database"
    - "File upload utility validates MIME type and file size (25MB max) and saves to uploads/ directory"
    - "Uploaded files are served through /api/uploads/[...path] with path traversal protection"
    - "@hello-pangea/dnd package is installed"
    - "Database migration applies cleanly with no schema conflicts"
  artifacts:
    - path: "src/db/schema/domain.ts"
      provides: "All new table definitions for Phase 4"
      contains: "maintenanceRequests"
    - path: "src/lib/uploads.ts"
      provides: "File upload utility with validation"
      exports: ["saveUploadedFile", "ALLOWED_MIME_TYPES", "MAX_FILE_SIZE"]
    - path: "src/app/api/uploads/[...path]/route.ts"
      provides: "Authenticated file serving with path traversal protection"
      exports: ["GET"]
  key_links:
    - from: "src/db/schema/domain.ts"
      to: "units table"
      via: "maintenanceRequests.unitId references units.id"
      pattern: "references.*units\\.id"
    - from: "src/app/api/uploads/[...path]/route.ts"
      to: "uploads/ directory"
      via: "fs.readFile from resolved path"
      pattern: "readFile"
---

<objective>
Install @hello-pangea/dnd, create all Phase 4 database schemas (maintenance requests, photos, comments, documents, document requests, emergency contacts), create file upload utility with validation, create file serving API route, and run database migration.

Purpose: Every other plan in Phase 4 depends on these schemas and the file upload infrastructure. This plan creates the foundational data layer that Plans 02-06 build on.

Output: All Phase 4 tables in domain schema, file upload utility (src/lib/uploads.ts), file serving route (/api/uploads/[...path]), @hello-pangea/dnd installed, database migration applied.
</objective>

<execution_context>
@/Users/odesantos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/odesantos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-maintenance-documents-and-profiles/04-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/db/schema/domain.ts (existing tables to reference):
```typescript
export const units = pgTable("units", {
  id: uuid("id").primaryKey().defaultRandom(),
  propertyId: uuid("property_id").references(() => properties.id, { onDelete: "cascade" }).notNull(),
  unitNumber: text("unit_number").notNull(),
  rentAmountCents: integer("rent_amount_cents"),
  rentDueDay: integer("rent_due_day"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
})

export const tenantUnits = pgTable("tenant_units", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: text("user_id").notNull(),  // text, NOT uuid — matches Better Auth user.id
  unitId: uuid("unit_id").references(() => units.id, { onDelete: "cascade" }).notNull(),
  // ...
})
```

From src/db/index.ts:
```typescript
export const db = new Proxy({} as NeonHttpDatabase<typeof schema>, { ... })
export type DB = NeonHttpDatabase<typeof schema>
```

From src/lib/auth.ts (session type):
```typescript
export type Session = typeof auth.$Infer.Session
export type User = typeof auth.$Infer.Session.user
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install @hello-pangea/dnd and add all Phase 4 database schemas</name>
  <files>
    package.json
    src/db/schema/domain.ts
  </files>
  <action>
Step 1 — Install the drag-and-drop library for the admin kanban board:
```bash
cd /Users/odesantos/Documents/rentalmgmt
npm install @hello-pangea/dnd
```

Step 2 — Add ALL Phase 4 tables to src/db/schema/domain.ts AFTER the existing `payments` table. Do NOT modify any existing tables. You will need to add `boolean` to the imports from `drizzle-orm/pg-core` if not already present. Append these tables:

```typescript
// ==================== Phase 4: Maintenance, Documents, Profiles ====================

// Maintenance requests with 4-stage status progression
export const maintenanceRequests = pgTable("maintenance_requests", {
  id: uuid("id").primaryKey().defaultRandom(),
  tenantUserId: text("tenant_user_id").notNull(),   // Better Auth user.id (text, NOT uuid)
  unitId: uuid("unit_id")
    .references(() => units.id, { onDelete: "cascade" })
    .notNull(),
  category: text("category", {
    enum: ["plumbing", "electrical", "hvac", "appliance", "pest_control", "structural", "general"],
  }).notNull(),
  description: text("description").notNull(),
  status: text("status", {
    enum: ["submitted", "acknowledged", "in_progress", "resolved"],
  }).default("submitted").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  resolvedAt: timestamp("resolved_at"),
})

// Photos attached to maintenance requests (up to 5 per request)
export const maintenancePhotos = pgTable("maintenance_photos", {
  id: uuid("id").primaryKey().defaultRandom(),
  requestId: uuid("request_id")
    .references(() => maintenanceRequests.id, { onDelete: "cascade" })
    .notNull(),
  filePath: text("file_path").notNull(),       // relative path from uploads root
  fileName: text("file_name").notNull(),       // original filename
  fileSize: integer("file_size").notNull(),    // bytes
  mimeType: text("mime_type").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
})

// Threaded comments on maintenance requests (tenant + admin)
export const maintenanceComments = pgTable("maintenance_comments", {
  id: uuid("id").primaryKey().defaultRandom(),
  requestId: uuid("request_id")
    .references(() => maintenanceRequests.id, { onDelete: "cascade" })
    .notNull(),
  userId: text("user_id").notNull(),           // can be tenant or admin
  content: text("content").notNull(),
  isStatusChange: boolean("is_status_change").default(false).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
})

// Tenant documents (uploaded files)
export const documents = pgTable("documents", {
  id: uuid("id").primaryKey().defaultRandom(),
  tenantUserId: text("tenant_user_id").notNull(),
  documentType: text("document_type", {
    enum: ["government_id", "proof_of_income_insurance", "general"],
  }).notNull(),
  filePath: text("file_path").notNull(),       // relative path from uploads root
  fileName: text("file_name").notNull(),
  fileSize: integer("file_size").notNull(),    // bytes
  mimeType: text("mime_type").notNull(),
  requestId: uuid("request_id"),               // links to admin request if this was requested
  createdAt: timestamp("created_at").defaultNow().notNull(),
})

// Admin document requests
export const documentRequests = pgTable("document_requests", {
  id: uuid("id").primaryKey().defaultRandom(),
  tenantUserId: text("tenant_user_id").notNull(),
  documentType: text("document_type", {
    enum: ["government_id", "proof_of_income_insurance", "general"],
  }).notNull(),
  message: text("message"),                    // optional admin note
  status: text("status", {
    enum: ["pending", "submitted"],
  }).default("pending").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  fulfilledAt: timestamp("fulfilled_at"),
})

// Emergency contacts for tenants
export const emergencyContacts = pgTable("emergency_contacts", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: text("user_id").notNull().unique(),  // one emergency contact per tenant
  contactName: text("contact_name").notNull(),
  contactPhone: text("contact_phone").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
})
```

CRITICAL: All user ID fields use text() not uuid() — matching Better Auth user.id type and existing project convention.
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && npx tsx -e "import('./src/db/schema/domain.ts').then(m => { const tables = ['maintenanceRequests','maintenancePhotos','maintenanceComments','documents','documentRequests','emergencyContacts']; tables.forEach(t => console.log(t + ':', typeof (m as any)[t])); })" 2>&1</automated>
  </verify>
  <done>
    @hello-pangea/dnd in package.json dependencies. Six new tables defined in domain.ts: maintenanceRequests (7 issue categories, 4-stage status), maintenancePhotos (with filePath, fileName, fileSize, mimeType), maintenanceComments (with isStatusChange flag), documents (with documentType enum and optional requestId), documentRequests (with pending/submitted status), emergencyContacts (with unique userId constraint). All user ID fields use text() type.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create file upload utility, file serving route, and run database migration</name>
  <files>
    src/lib/uploads.ts
    src/app/api/uploads/[...path]/route.ts
    uploads/.gitkeep
    .gitignore
  </files>
  <action>
Step 1 — Create the uploads directory and .gitkeep:
```bash
cd /Users/odesantos/Documents/rentalmgmt
mkdir -p uploads
touch uploads/.gitkeep
```

Step 2 — Add `uploads/` to .gitignore (but NOT uploads/.gitkeep). Append to the existing .gitignore:
```
# Uploaded files (local storage)
uploads/*
!uploads/.gitkeep
```

Step 3 — Create src/lib/uploads.ts:

```typescript
import { promises as fs } from "fs"
import path from "path"
import crypto from "crypto"

export const UPLOADS_DIR = path.join(process.cwd(), "uploads")

export const ALLOWED_MIME_TYPES = new Set([
  "image/jpeg",
  "image/png",
  "image/heic",
  "image/heif",
  "application/pdf",
  "application/msword",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
])

export const MAX_FILE_SIZE = 25 * 1024 * 1024 // 25MB

export async function saveUploadedFile(
  file: File,
  subdirectory: string,
): Promise<{ filePath: string; fileName: string; fileSize: number; mimeType: string }> {
  if (file.size > MAX_FILE_SIZE) {
    throw new Error(`File too large: ${(file.size / 1024 / 1024).toFixed(1)}MB (max 25MB)`)
  }
  if (!ALLOWED_MIME_TYPES.has(file.type)) {
    throw new Error(`Unsupported file type: ${file.type}. Accepted: PDF, JPG, PNG, HEIC, Word docs`)
  }

  const ext = path.extname(file.name) || ""
  const safeName = `${crypto.randomUUID()}${ext}`
  const relPath = path.join(subdirectory, safeName)
  const fullPath = path.join(UPLOADS_DIR, relPath)

  await fs.mkdir(path.dirname(fullPath), { recursive: true })
  const bytes = await file.arrayBuffer()
  await fs.writeFile(fullPath, Buffer.from(bytes))

  return {
    filePath: relPath,
    fileName: file.name,
    fileSize: file.size,
    mimeType: file.type,
  }
}
```

Step 4 — Create src/app/api/uploads/[...path]/route.ts for serving uploaded files with auth check and path traversal protection:

```typescript
import { promises as fs } from "fs"
import path from "path"
import { auth } from "@/lib/auth"
import { headers } from "next/headers"
import { UPLOADS_DIR } from "@/lib/uploads"

const MIME_TYPES: Record<string, string> = {
  ".jpg": "image/jpeg",
  ".jpeg": "image/jpeg",
  ".png": "image/png",
  ".heic": "image/heic",
  ".heif": "image/heif",
  ".pdf": "application/pdf",
  ".doc": "application/msword",
  ".docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
}

export async function GET(
  request: Request,
  { params }: { params: Promise<{ path: string[] }> }
) {
  // Auth check — only authenticated users can access uploads
  const session = await auth.api.getSession({ headers: await headers() })
  if (!session) {
    return new Response("Unauthorized", { status: 401 })
  }

  const { path: pathSegments } = await params
  const filePath = path.join(UPLOADS_DIR, ...pathSegments)

  // Path traversal protection — verify resolved path stays within uploads directory
  const resolvedPath = path.resolve(filePath)
  if (!resolvedPath.startsWith(path.resolve(UPLOADS_DIR))) {
    return new Response("Forbidden", { status: 403 })
  }

  try {
    const buffer = await fs.readFile(resolvedPath)
    const ext = path.extname(resolvedPath).toLowerCase()
    const contentType = MIME_TYPES[ext] || "application/octet-stream"

    return new Response(buffer, {
      headers: {
        "Content-Type": contentType,
        "Cache-Control": "private, max-age=3600",
      },
    })
  } catch {
    return new Response("Not Found", { status: 404 })
  }
}
```

Step 5 — Generate and apply the database migration:
```bash
cd /Users/odesantos/Documents/rentalmgmt
npm run db:generate
npm run db:push
```

This creates all 6 new tables in Neon. Existing tables should NOT be modified.
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && npm run build 2>&1 | tail -5</automated>
  </verify>
  <done>
    src/lib/uploads.ts exports saveUploadedFile, ALLOWED_MIME_TYPES, MAX_FILE_SIZE. src/app/api/uploads/[...path]/route.ts serves files with auth check and path traversal protection. uploads/ directory exists with .gitkeep. .gitignore excludes upload contents. npm run build passes. Database migration applied — all 6 new tables exist in Neon.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npm run build` passes with no TypeScript errors
2. @hello-pangea/dnd in node_modules
3. src/db/schema/domain.ts contains all 6 new tables
4. src/lib/uploads.ts exports saveUploadedFile with 25MB limit and MIME validation
5. src/app/api/uploads/[...path]/route.ts serves files with auth and path traversal checks
6. uploads/.gitkeep exists, uploads/ in .gitignore
7. Database migration applied (all 6 new tables exist in Neon)
</verification>

<success_criteria>
- All 6 new database tables defined with correct column types and relationships
- All user ID fields use text() matching Better Auth user.id type
- File upload utility validates MIME type and size before saving
- File serving route has auth check and path traversal protection
- @hello-pangea/dnd installed for admin kanban board
- Database migration applied cleanly
- npm run build passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-maintenance-documents-and-profiles/04-01-SUMMARY.md`
</output>
