---
phase: 03-payments
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema/domain.ts
  - src/db/schema/index.ts
  - src/lib/stripe.ts
  - package.json
  - .env.example
autonomous: true
requirements:
  - PAY-01
  - PAY-02
  - PAY-05

must_haves:
  truths:
    - "payments table exists in the database with columns: id, tenantUserId, unitId, amountCents, stripeSessionId, stripePaymentIntentId, paymentMethod, status, billingPeriod, note, paidAt, createdAt, updatedAt"
    - "Stripe client can be imported from @/lib/stripe without build errors"
    - "stripe and @react-pdf/renderer packages are installed"
    - "Database migration applies cleanly with no schema conflicts"
  artifacts:
    - path: "src/db/schema/domain.ts"
      provides: "payments table definition with all columns and correct types"
      contains: "payments"
    - path: "src/lib/stripe.ts"
      provides: "Lazy-initialized Stripe client using Proxy pattern"
      exports: ["stripe"]
    - path: "package.json"
      provides: "stripe and @react-pdf/renderer dependencies"
      contains: "stripe"
  key_links:
    - from: "src/db/schema/domain.ts"
      to: "units table"
      via: "payments.unitId references units.id"
      pattern: "references.*units\\.id"
    - from: "src/lib/stripe.ts"
      to: "STRIPE_SECRET_KEY"
      via: "process.env.STRIPE_SECRET_KEY"
      pattern: "STRIPE_SECRET_KEY"
---

<objective>
Install Stripe and PDF dependencies, create the payments database schema, configure the Stripe client using the project's lazy Proxy pattern, and run the database migration.

Purpose: Every other plan in Phase 3 depends on the payments table and Stripe client existing. This plan creates the foundational data layer and client configuration that Plans 03-06 build on.

Output: payments table in domain schema, Stripe client (src/lib/stripe.ts), @react-pdf/renderer installed, database migration applied to Neon.
</objective>

<execution_context>
@/Users/odesantos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/odesantos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-payments/03-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/db/schema/domain.ts (existing tables):
```typescript
export const properties = pgTable("properties", {
  id: uuid("id").primaryKey().defaultRandom(),
  name: text("name").notNull(),
  address: text("address").notNull(),
  // ...
})

export const units = pgTable("units", {
  id: uuid("id").primaryKey().defaultRandom(),
  propertyId: uuid("property_id").references(() => properties.id, { onDelete: "cascade" }).notNull(),
  unitNumber: text("unit_number").notNull(),
  rentAmountCents: integer("rent_amount_cents"),  // nullable until Phase 3 configures it
  rentDueDay: integer("rent_due_day"),             // day of month 1-28, nullable until Phase 3
  // ...
})

export const tenantUnits = pgTable("tenant_units", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: text("user_id").notNull(),              // text, NOT uuid — matches Better Auth user.id
  unitId: uuid("unit_id").references(() => units.id, { onDelete: "cascade" }).notNull(),
  // ...
})
```

From src/db/index.ts:
```typescript
export const db = new Proxy({} as NeonHttpDatabase<typeof schema>, { ... })
export type DB = NeonHttpDatabase<typeof schema>
```

From src/lib/resend.ts (pattern to follow for stripe.ts):
```typescript
let _resend: Resend | null = null
export function getResend(): Resend { ... }
export const resend = new Proxy({} as Resend, {
  get(_target, prop, receiver) {
    return Reflect.get(getResend(), prop, receiver)
  },
})
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Stripe and PDF packages, add payments schema</name>
  <files>
    package.json
    src/db/schema/domain.ts
    .env.example
  </files>
  <action>
Step 1 — Install packages:
```bash
cd /Users/odesantos/Documents/rentalmgmt
npm install stripe @react-pdf/renderer
```

Step 2 — Add the payments table to src/db/schema/domain.ts AFTER the existing inviteTokens table. Do NOT modify any existing tables. Append:

```typescript
// Payments — tracks all rent payments (Stripe and manual/offline)
export const payments = pgTable("payments", {
  id: uuid("id").primaryKey().defaultRandom(),
  tenantUserId: text("tenant_user_id").notNull(),     // Better Auth user.id (text, NOT uuid)
  unitId: uuid("unit_id")
    .references(() => units.id, { onDelete: "cascade" })
    .notNull(),
  amountCents: integer("amount_cents").notNull(),      // amount in cents (e.g., 150000 = $1,500.00)
  stripeSessionId: text("stripe_session_id").unique(), // null for manual payments, unique to prevent duplicates
  stripePaymentIntentId: text("stripe_payment_intent_id"),
  paymentMethod: text("payment_method", {
    enum: ["card", "ach", "cash", "check", "venmo", "other"],
  }).notNull(),
  status: text("status", {
    enum: ["pending", "succeeded", "failed"],
  }).notNull(),
  billingPeriod: text("billing_period").notNull(),     // "2026-03" YYYY-MM format
  note: text("note"),                                   // for manual payment descriptions
  paidAt: timestamp("paid_at"),                         // when payment was confirmed
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
})
```

CRITICAL: tenantUserId uses text() not uuid() — matching Better Auth user.id type and the existing tenantUnits.userId pattern.

CRITICAL: stripeSessionId has .unique() to prevent duplicate payment records from webhook retries.

Step 3 — Add STRIPE env vars to .env.example (append to existing content, do not remove existing vars):
```
STRIPE_SECRET_KEY=
STRIPE_WEBHOOK_SECRET=
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=
```

Also add these to .env.local with placeholder comments if they don't already exist.
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && npx tsx -e "import('./src/db/schema/domain.ts').then(m => { console.log('payments table:', typeof m.payments); console.log('Has amountCents:', 'amountCents' in (m.payments as any)); })" 2>&1</automated>
  </verify>
  <done>
    stripe and @react-pdf/renderer in package.json dependencies. payments table defined in domain.ts with all required columns: id, tenantUserId (text), unitId (uuid FK), amountCents (integer), stripeSessionId (text, unique), stripePaymentIntentId, paymentMethod (enum), status (enum), billingPeriod, note, paidAt, createdAt, updatedAt. .env.example updated with Stripe vars.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Stripe client and run database migration</name>
  <files>
    src/lib/stripe.ts
  </files>
  <action>
Step 1 — Create src/lib/stripe.ts using the SAME lazy Proxy pattern as src/lib/resend.ts and src/db/index.ts:

```typescript
import Stripe from "stripe"

// Lazy initialization to prevent build failures when STRIPE_SECRET_KEY is not yet set.
// Matches the pattern used by db (src/db/index.ts) and resend (src/lib/resend.ts).
let _stripe: Stripe | null = null

export function getStripe(): Stripe {
  if (!_stripe) {
    const secretKey = process.env.STRIPE_SECRET_KEY
    if (!secretKey) {
      throw new Error(
        "STRIPE_SECRET_KEY is not set. Please set it in .env.local to your Stripe secret key."
      )
    }
    _stripe = new Stripe(secretKey)
  }
  return _stripe
}

// Export a proxy that lazily creates the Stripe instance on first access.
export const stripe = new Proxy({} as Stripe, {
  get(_target, prop, receiver) {
    return Reflect.get(getStripe(), prop, receiver)
  },
})
```

Step 2 — Generate and apply the database migration:
```bash
cd /Users/odesantos/Documents/rentalmgmt
npm run db:generate
npm run db:push
```

This creates the payments table in Neon. The migration should add ONLY the payments table — the existing tables (properties, units, tenantUnits, inviteTokens, Better Auth tables) should not be modified.
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && npm run build 2>&1 | tail -5</automated>
  </verify>
  <done>
    src/lib/stripe.ts exports `stripe` using lazy Proxy pattern. `npm run build` passes. Database migration applied — payments table exists in Neon. No existing tables modified.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npm run build` passes with no TypeScript errors
2. `stripe` and `@react-pdf/renderer` packages present in node_modules
3. src/db/schema/domain.ts contains the payments table with stripeSessionId unique constraint
4. src/lib/stripe.ts exports a lazy Stripe client
5. .env.example contains STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET, NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY
6. Database migration created and applied (payments table exists in Neon)
</verification>

<success_criteria>
- payments table schema defined with all required columns and correct types
- stripeSessionId has unique constraint for idempotent webhook processing
- Stripe client follows project's lazy Proxy pattern
- Both stripe and @react-pdf/renderer installed
- Database migration applied cleanly
- npm run build passes
</success_criteria>

<output>
After completion, create `.planning/phases/03-payments/03-01-SUMMARY.md`
</output>
