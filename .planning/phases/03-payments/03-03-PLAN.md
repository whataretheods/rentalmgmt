---
phase: 03-payments
plan: 03
type: execute
wave: 2
depends_on: [01]
files_modified:
  - src/app/api/payments/create-checkout/route.ts
  - src/app/api/webhooks/stripe/route.ts
  - src/app/(tenant)/tenant/payments/success/page.tsx
autonomous: true
requirements:
  - PAY-01
  - NOTIF-02

user_setup:
  - service: stripe
    why: "Payment processing — Stripe Checkout Sessions and webhooks"
    env_vars:
      - name: STRIPE_SECRET_KEY
        source: "Stripe Dashboard -> Developers -> API keys -> Secret key"
      - name: STRIPE_WEBHOOK_SECRET
        source: "Stripe CLI: stripe listen --forward-to localhost:3000/api/webhooks/stripe (prints whsec_...)"
      - name: NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY
        source: "Stripe Dashboard -> Developers -> API keys -> Publishable key"
    dashboard_config:
      - task: "Enable ACH Direct Debit payment method"
        location: "Stripe Dashboard -> Settings -> Payment methods -> Enable 'ACH Direct Debit'"
      - task: "Create webhook endpoint (production)"
        location: "Stripe Dashboard -> Developers -> Webhooks -> Add endpoint -> URL: https://yourdomain.com/api/webhooks/stripe -> Events: checkout.session.completed, checkout.session.async_payment_succeeded, checkout.session.async_payment_failed"

must_haves:
  truths:
    - "Tenant can click Pay Rent and be redirected to Stripe Checkout with card and ACH options"
    - "After successful card payment, webhook records payment in database with status 'succeeded'"
    - "After ACH checkout, webhook records payment with status 'pending', then updates to 'succeeded' on async_payment_succeeded"
    - "Tenant receives email confirmation after successful payment"
    - "Success page shows payment confirmation after redirect from Stripe"
    - "Duplicate webhook events do not create duplicate payment records"
  artifacts:
    - path: "src/app/api/payments/create-checkout/route.ts"
      provides: "POST endpoint creating Stripe Checkout Session with card + ACH"
      exports: ["POST"]
    - path: "src/app/api/webhooks/stripe/route.ts"
      provides: "Webhook handler for checkout.session.completed, async_payment_succeeded, async_payment_failed"
      exports: ["POST"]
    - path: "src/app/(tenant)/tenant/payments/success/page.tsx"
      provides: "Post-checkout success confirmation page"
  key_links:
    - from: "src/app/api/payments/create-checkout/route.ts"
      to: "stripe.checkout.sessions.create"
      via: "Creates Checkout Session with metadata (tenantUserId, unitId, billingPeriod)"
      pattern: "checkout\\.sessions\\.create"
    - from: "src/app/api/webhooks/stripe/route.ts"
      to: "src/db/schema/domain.ts"
      via: "Inserts/updates payments table based on webhook events"
      pattern: "db\\.insert.*payments|db\\.update.*payments"
    - from: "src/app/api/webhooks/stripe/route.ts"
      to: "src/lib/resend.ts"
      via: "Sends confirmation email after successful payment"
      pattern: "resend\\.emails\\.send"
---

<objective>
Build the core Stripe payment flow: Checkout Session creation API, webhook handler for payment confirmation, email notification on success, and the post-checkout success page.

Purpose: PAY-01 (tenant pays rent via Stripe) and NOTIF-02 (email confirmation) are the core value of this phase. The webhook-first pattern ensures payments are only recorded after Stripe confirms them — never from the redirect URL.

Output: Create-checkout API endpoint, Stripe webhook handler processing 3 event types, payment confirmation email, and success page.
</objective>

<execution_context>
@/Users/odesantos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/odesantos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-payments/03-RESEARCH.md
@.planning/phases/03-payments/03-01-SUMMARY.md

<interfaces>
<!-- Key types and contracts from Plan 01 outputs -->

From src/db/schema/domain.ts (after Plan 01):
```typescript
export const payments = pgTable("payments", {
  id: uuid("id").primaryKey().defaultRandom(),
  tenantUserId: text("tenant_user_id").notNull(),
  unitId: uuid("unit_id").references(() => units.id, { onDelete: "cascade" }).notNull(),
  amountCents: integer("amount_cents").notNull(),
  stripeSessionId: text("stripe_session_id").unique(),
  stripePaymentIntentId: text("stripe_payment_intent_id"),
  paymentMethod: text("payment_method", { enum: ["card", "ach", "cash", "check", "venmo", "other"] }).notNull(),
  status: text("status", { enum: ["pending", "succeeded", "failed"] }).notNull(),
  billingPeriod: text("billing_period").notNull(),
  note: text("note"),
  paidAt: timestamp("paid_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
})

export const units = pgTable("units", {
  id: uuid("id").primaryKey().defaultRandom(),
  unitNumber: text("unit_number").notNull(),
  rentAmountCents: integer("rent_amount_cents"),
  rentDueDay: integer("rent_due_day"),
  // ...
})

export const tenantUnits = pgTable("tenant_units", {
  userId: text("user_id").notNull(),
  unitId: uuid("unit_id").references(() => units.id).notNull(),
  isActive: boolean("is_active").default(true).notNull(),
  // ...
})
```

From src/lib/stripe.ts (after Plan 01):
```typescript
export const stripe = new Proxy({} as Stripe, { ... })  // lazy init
```

From src/lib/resend.ts:
```typescript
export const resend = new Proxy({} as Resend, { ... })  // lazy init
```

From src/lib/auth.ts:
```typescript
export const auth = betterAuth({ ... })
export type Session = typeof auth.$Infer.Session
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Stripe Checkout Session API endpoint</name>
  <files>
    src/app/api/payments/create-checkout/route.ts
  </files>
  <action>
Create src/app/api/payments/create-checkout/route.ts:

```typescript
import { NextResponse } from "next/server"
import { auth } from "@/lib/auth"
import { headers } from "next/headers"
import { stripe } from "@/lib/stripe"
import { db } from "@/db"
import { units, tenantUnits } from "@/db/schema"
import { eq, and } from "drizzle-orm"
import { z } from "zod"

const checkoutSchema = z.object({
  unitId: z.string().uuid(),
  amountCents: z.number().int().min(1).max(10000000),  // $0.01 to $100,000
})

export async function POST(req: Request) {
  // Auth check — tenant must be logged in
  const session = await auth.api.getSession({ headers: await headers() })
  if (!session) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
  }

  const body = await req.json()
  const parsed = checkoutSchema.safeParse(body)
  if (!parsed.success) {
    return NextResponse.json({ error: "Invalid input", details: parsed.error.flatten() }, { status: 400 })
  }

  const { unitId, amountCents } = parsed.data

  // Verify tenant is linked to this unit
  const [link] = await db
    .select()
    .from(tenantUnits)
    .where(
      and(
        eq(tenantUnits.userId, session.user.id),
        eq(tenantUnits.unitId, unitId),
        eq(tenantUnits.isActive, true)
      )
    )

  if (!link) {
    return NextResponse.json({ error: "Not linked to this unit" }, { status: 403 })
  }

  // Get unit details for checkout display
  const [unit] = await db.select().from(units).where(eq(units.id, unitId))
  if (!unit) {
    return NextResponse.json({ error: "Unit not found" }, { status: 404 })
  }

  const origin = req.headers.get("origin") || "http://localhost:3000"
  const billingPeriod = new Date().toISOString().slice(0, 7)  // "2026-03"

  // Create Stripe Checkout Session
  const checkoutSession = await stripe.checkout.sessions.create({
    payment_method_types: ["card", "us_bank_account"],
    mode: "payment",
    customer_email: session.user.email,
    line_items: [
      {
        price_data: {
          currency: "usd",
          product_data: {
            name: `Rent - Unit ${unit.unitNumber}`,
            description: `Rent payment for ${billingPeriod}`,
          },
          unit_amount: amountCents,
        },
        quantity: 1,
      },
    ],
    metadata: {
      tenantUserId: session.user.id,
      unitId: unitId,
      billingPeriod: billingPeriod,
    },
    success_url: `${origin}/tenant/payments/success?session_id={CHECKOUT_SESSION_ID}`,
    cancel_url: `${origin}/tenant/dashboard`,
  })

  return NextResponse.json({ url: checkoutSession.url })
}
```

CRITICAL: payment_method_types includes BOTH "card" and "us_bank_account" (ACH) per user decision.
CRITICAL: metadata contains tenantUserId, unitId, billingPeriod — webhook reads these to create payment record.
CRITICAL: Tenant can adjust amount (amountCents from request body, NOT forced to unit.rentAmountCents) — per user decision allowing partial/over payments.
CRITICAL: success_url uses {CHECKOUT_SESSION_ID} template — Stripe replaces this with the actual session ID.
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && npm run build 2>&1 | tail -5</automated>
  </verify>
  <done>
    POST /api/payments/create-checkout validates auth, verifies tenant-unit link, creates Stripe Checkout Session with card + ACH, includes metadata for webhook, returns session URL. Amount comes from request body (tenant can adjust per user decision).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Stripe webhook handler and payment success page</name>
  <files>
    src/app/api/webhooks/stripe/route.ts
    src/app/(tenant)/tenant/payments/success/page.tsx
  </files>
  <action>
Step 1 — Create src/app/api/webhooks/stripe/route.ts:

```typescript
import { Stripe } from "stripe"
import { NextResponse } from "next/server"
import { headers } from "next/headers"
import { db } from "@/db"
import { payments, units } from "@/db/schema"
import { eq } from "drizzle-orm"
import { resend } from "@/lib/resend"

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY as string)

export async function POST(req: Request) {
  let event: Stripe.Event

  try {
    const stripeSignature = (await headers()).get("stripe-signature")
    event = stripe.webhooks.constructEvent(
      await req.text(),
      stripeSignature as string,
      process.env.STRIPE_WEBHOOK_SECRET as string
    )
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : "Unknown error"
    console.error("Webhook signature verification failed:", errorMessage)
    return NextResponse.json({ error: "Webhook signature verification failed" }, { status: 400 })
  }

  try {
    switch (event.type) {
      case "checkout.session.completed": {
        const session = event.data.object as Stripe.Checkout.Session
        const { tenantUserId, unitId, billingPeriod } = session.metadata || {}

        if (!tenantUserId || !unitId || !billingPeriod) {
          console.error("Missing metadata in checkout session:", session.id)
          break
        }

        // Determine payment method type
        const paymentMethod = session.payment_method_types?.includes("us_bank_account")
          && session.payment_status === "unpaid"
          ? "ach"
          : "card"

        if (session.payment_status === "paid") {
          // Card payment — immediately confirmed
          await db.insert(payments).values({
            tenantUserId,
            unitId,
            amountCents: session.amount_total!,
            stripeSessionId: session.id,
            stripePaymentIntentId: session.payment_intent as string,
            paymentMethod: "card",
            status: "succeeded",
            billingPeriod,
            paidAt: new Date(),
          }).onConflictDoNothing()  // idempotent — stripeSessionId is unique

          // Send confirmation email
          await sendPaymentConfirmation(tenantUserId, unitId, session.amount_total!, billingPeriod)
        } else if (session.payment_status === "unpaid") {
          // ACH — pending bank verification/settlement (3-5 business days)
          await db.insert(payments).values({
            tenantUserId,
            unitId,
            amountCents: session.amount_total!,
            stripeSessionId: session.id,
            stripePaymentIntentId: session.payment_intent as string,
            paymentMethod: "ach",
            status: "pending",
            billingPeriod,
          }).onConflictDoNothing()
        }
        break
      }

      case "checkout.session.async_payment_succeeded": {
        // ACH payment settled successfully
        const session = event.data.object as Stripe.Checkout.Session
        const { tenantUserId, unitId, billingPeriod } = session.metadata || {}

        await db
          .update(payments)
          .set({ status: "succeeded", paidAt: new Date(), updatedAt: new Date() })
          .where(eq(payments.stripeSessionId, session.id))

        if (tenantUserId && unitId && billingPeriod) {
          await sendPaymentConfirmation(tenantUserId, unitId, session.amount_total!, billingPeriod)
        }
        break
      }

      case "checkout.session.async_payment_failed": {
        // ACH payment failed
        const session = event.data.object as Stripe.Checkout.Session
        await db
          .update(payments)
          .set({ status: "failed", updatedAt: new Date() })
          .where(eq(payments.stripeSessionId, session.id))
        break
      }

      default:
        // Unhandled event type — log but don't error
        console.log("Unhandled webhook event type:", event.type)
    }
  } catch (err) {
    console.error("Webhook handler error:", err)
    return NextResponse.json({ error: "Webhook handler failed" }, { status: 500 })
  }

  return NextResponse.json({ received: true }, { status: 200 })
}

// Helper: send payment confirmation email
async function sendPaymentConfirmation(
  tenantUserId: string,
  unitId: string,
  amountCents: number,
  billingPeriod: string
) {
  try {
    // Fetch user email from Better Auth user table
    const userResult = await db.execute(
      `SELECT email, name FROM "user" WHERE id = '${tenantUserId}'`
    )
    // Note: db.execute returns NeonQueryResult. Access rows directly.
    const user = (userResult as unknown as { rows: Array<{ email: string; name: string }> }).rows?.[0]
    if (!user?.email) {
      console.warn("Could not find user email for payment confirmation:", tenantUserId)
      return
    }

    // Fetch unit number
    const [unit] = await db.select().from(units).where(eq(units.id, unitId))
    const unitNumber = unit?.unitNumber || "Unknown"

    const amount = `$${(amountCents / 100).toFixed(2)}`

    // Do NOT await — prevent timing issues. Fire and forget email.
    void resend.emails.send({
      from: "RentalMgmt <noreply@rentalmgmt.com>",
      to: user.email,
      subject: "Payment Confirmation",
      html: `
        <h2>Payment Confirmed</h2>
        <p>Hi ${user.name || "Tenant"},</p>
        <p>Your rent payment has been received and confirmed.</p>
        <table style="border-collapse: collapse; margin: 16px 0;">
          <tr><td style="padding: 4px 16px 4px 0; color: #666;">Amount</td><td style="font-weight: bold;">${amount}</td></tr>
          <tr><td style="padding: 4px 16px 4px 0; color: #666;">Unit</td><td style="font-weight: bold;">${unitNumber}</td></tr>
          <tr><td style="padding: 4px 16px 4px 0; color: #666;">Period</td><td style="font-weight: bold;">${billingPeriod}</td></tr>
          <tr><td style="padding: 4px 16px 4px 0; color: #666;">Date</td><td style="font-weight: bold;">${new Date().toLocaleDateString()}</td></tr>
        </table>
        <p style="color: #666; font-size: 14px;">Thank you for your payment.</p>
      `,
    })
  } catch (err) {
    // Email failures should NOT block webhook processing
    console.error("Failed to send payment confirmation email:", err)
  }
}
```

CRITICAL: Use `await req.text()` for raw body — NOT req.json(). JSON parsing breaks signature verification.
CRITICAL: Use `.onConflictDoNothing()` on insert — stripeSessionId unique constraint prevents duplicate records from webhook retries.
CRITICAL: ACH payments arrive as checkout.session.completed with payment_status="unpaid". The actual confirmation comes via checkout.session.async_payment_succeeded.
CRITICAL: Email is fire-and-forget (void resend.emails.send) — do NOT let email failure block webhook response.
CRITICAL: Always return 200 to Stripe — even on handler errors, log them but respond 200 to prevent infinite retries.

NOTE on user email query: Better Auth's user table is named "user" (with quotes required in SQL). We use db.execute for this raw query since Drizzle's relational queries need the user schema table definition which is in auth.ts. This is a pragmatic approach to avoid importing the entire auth schema into the webhook handler.

Step 2 — Create src/app/(tenant)/tenant/payments/success/page.tsx:

```typescript
import Link from "next/link"

export default async function PaymentSuccessPage({
  searchParams,
}: {
  searchParams: Promise<{ session_id?: string }>
}) {
  const { session_id } = await searchParams

  return (
    <div className="max-w-md mx-auto text-center py-12">
      <div className="mb-6">
        <div className="inline-flex items-center justify-center w-16 h-16 rounded-full bg-green-100">
          <svg className="w-8 h-8 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
          </svg>
        </div>
      </div>

      <h1 className="text-2xl font-bold text-gray-900">Payment Submitted</h1>
      <p className="mt-3 text-gray-600">
        Your rent payment has been submitted successfully.
        {session_id ? " You will receive a confirmation email shortly." : ""}
      </p>
      <p className="mt-2 text-sm text-gray-500">
        If you paid via bank transfer (ACH), your payment may take 3-5 business days to process.
      </p>

      <div className="mt-8 flex flex-col gap-3">
        <Link
          href="/tenant/dashboard"
          className="inline-flex items-center justify-center rounded-md bg-gray-900 px-4 py-2 text-sm font-medium text-white hover:bg-gray-800"
        >
          Back to Dashboard
        </Link>
        <Link
          href="/tenant/payments"
          className="inline-flex items-center justify-center rounded-md bg-gray-100 px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-200"
        >
          View Payment History
        </Link>
      </div>
    </div>
  )
}
```

NOTE: searchParams is a Promise in Next.js 15 — must await it.
NOTE: This page does NOT verify payment status from the session_id — that's the webhook's job (webhook-first principle). This page is purely informational.
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && npm run build 2>&1 | tail -5</automated>
  </verify>
  <done>
    POST /api/webhooks/stripe verifies signature, handles checkout.session.completed (card=succeeded, ACH=pending), checkout.session.async_payment_succeeded (ACH settled), checkout.session.async_payment_failed. Idempotent via onConflictDoNothing + stripeSessionId unique. Sends confirmation email on success. Success page at /tenant/payments/success shows confirmation with ACH processing note. npm run build passes.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npm run build` passes
2. POST /api/payments/create-checkout creates a Stripe Checkout Session with card + ACH
3. POST /api/webhooks/stripe correctly verifies signature using req.text()
4. Webhook handles all 3 event types (completed, async_payment_succeeded, async_payment_failed)
5. Duplicate webhooks don't create duplicate payments (stripeSessionId unique + onConflictDoNothing)
6. Email confirmation sent after card payment and after ACH settlement
7. Success page renders at /tenant/payments/success
</verification>

<success_criteria>
- Tenant can initiate Stripe Checkout with card and ACH options
- Webhook-first: payments only recorded after Stripe webhook confirmation
- Card payments immediately marked as succeeded
- ACH payments initially pending, updated on async settlement
- Idempotent webhook processing prevents duplicates
- Email confirmation sent on successful payment
- Success page shows appropriate messaging including ACH processing time
</success_criteria>

<output>
After completion, create `.planning/phases/03-payments/03-03-SUMMARY.md`
</output>
