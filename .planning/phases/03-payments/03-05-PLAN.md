---
phase: 03-payments
plan: 05
type: execute
wave: 3
depends_on: [01, 03]
files_modified:
  - src/app/(admin)/admin/payments/page.tsx
  - src/app/api/payments/manual/route.ts
  - src/components/admin/PaymentDashboard.tsx
  - src/components/admin/ManualPaymentForm.tsx
  - src/app/(admin)/admin/dashboard/page.tsx
autonomous: true
requirements:
  - PAY-05

must_haves:
  truths:
    - "Admin can see a table of all units with paid/unpaid status for the current billing period"
    - "Status badges are color-coded: Paid (green), Unpaid (red/gray), Partial (amber), Pending (yellow)"
    - "Admin can navigate to past months to view historical payment status"
    - "Admin can record a manual/offline payment with amount, method, and note"
    - "Manual payments appear in the same dashboard as Stripe payments"
  artifacts:
    - path: "src/app/(admin)/admin/payments/page.tsx"
      provides: "Admin payment dashboard page"
    - path: "src/components/admin/PaymentDashboard.tsx"
      provides: "Payment overview table with per-unit status badges"
    - path: "src/components/admin/ManualPaymentForm.tsx"
      provides: "Form for recording manual/offline payments"
    - path: "src/app/api/payments/manual/route.ts"
      provides: "POST endpoint for creating manual payment records"
      exports: ["POST"]
  key_links:
    - from: "src/components/admin/PaymentDashboard.tsx"
      to: "src/db/schema/domain.ts"
      via: "Aggregate query joining units, tenantUnits, payments for current period"
      pattern: "payments|tenantUnits|units"
    - from: "src/components/admin/ManualPaymentForm.tsx"
      to: "/api/payments/manual"
      via: "fetch POST to record offline payment"
      pattern: "payments/manual"
---

<objective>
Build the admin payment dashboard showing per-unit paid/unpaid status for the current period, with month navigation and the ability to record manual/offline payments.

Purpose: PAY-05 delivers the admin's at-a-glance view of who has paid and who hasn't. Combined with manual payment recording, this gives the admin complete visibility into all rent collection regardless of payment method.

Output: Admin payments page at /admin/payments with color-coded status table, month navigation, and manual payment recording.
</objective>

<execution_context>
@/Users/odesantos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/odesantos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-payments/03-RESEARCH.md
@.planning/phases/03-payments/03-01-SUMMARY.md
@.planning/phases/03-payments/03-03-SUMMARY.md

<interfaces>
From src/db/schema/domain.ts:
```typescript
export const payments = pgTable("payments", {
  id: uuid("id").primaryKey().defaultRandom(),
  tenantUserId: text("tenant_user_id").notNull(),
  unitId: uuid("unit_id").references(() => units.id).notNull(),
  amountCents: integer("amount_cents").notNull(),
  stripeSessionId: text("stripe_session_id").unique(),
  paymentMethod: text("payment_method", { enum: ["card", "ach", "cash", "check", "venmo", "other"] }).notNull(),
  status: text("status", { enum: ["pending", "succeeded", "failed"] }).notNull(),
  billingPeriod: text("billing_period").notNull(),
  note: text("note"),
  paidAt: timestamp("paid_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
})

export const units = pgTable("units", { ... })
export const tenantUnits = pgTable("tenant_units", { ... })
export const properties = pgTable("properties", { ... })
```

From src/lib/auth.ts:
```typescript
export const auth = betterAuth({ ... })
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create manual payment API and admin payment dashboard components</name>
  <files>
    src/app/api/payments/manual/route.ts
    src/components/admin/PaymentDashboard.tsx
    src/components/admin/ManualPaymentForm.tsx
  </files>
  <action>
Step 1 — Create src/app/api/payments/manual/route.ts:

```typescript
import { NextResponse } from "next/server"
import { auth } from "@/lib/auth"
import { headers } from "next/headers"
import { db } from "@/db"
import { payments, tenantUnits } from "@/db/schema"
import { eq, and } from "drizzle-orm"
import { z } from "zod"

const manualPaymentSchema = z.object({
  unitId: z.string().uuid(),
  amountCents: z.number().int().min(1).max(10000000),
  paymentMethod: z.enum(["cash", "check", "venmo", "other"]),
  billingPeriod: z.string().regex(/^\d{4}-\d{2}$/),  // "2026-03"
  note: z.string().max(500).optional(),
})

export async function POST(req: Request) {
  const session = await auth.api.getSession({ headers: await headers() })
  if (!session || session.user.role !== "admin") {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
  }

  const body = await req.json()
  const parsed = manualPaymentSchema.safeParse(body)
  if (!parsed.success) {
    return NextResponse.json({ error: "Invalid input", details: parsed.error.flatten() }, { status: 400 })
  }

  // Find the active tenant for this unit
  const [link] = await db
    .select()
    .from(tenantUnits)
    .where(and(eq(tenantUnits.unitId, parsed.data.unitId), eq(tenantUnits.isActive, true)))

  if (!link) {
    return NextResponse.json({ error: "No active tenant for this unit" }, { status: 400 })
  }

  // Create manual payment record
  const [payment] = await db.insert(payments).values({
    tenantUserId: link.userId,
    unitId: parsed.data.unitId,
    amountCents: parsed.data.amountCents,
    paymentMethod: parsed.data.paymentMethod,
    status: "succeeded",  // manual payments are immediately confirmed
    billingPeriod: parsed.data.billingPeriod,
    note: parsed.data.note || null,
    paidAt: new Date(),
  }).returning()

  return NextResponse.json({ payment })
}
```

NOTE: Manual payments have no stripeSessionId (null) — they're always "succeeded" immediately.
NOTE: Find the active tenant automatically from the unit — admin doesn't need to pick the tenant.

Step 2 — Create src/components/admin/ManualPaymentForm.tsx (client component):

```typescript
"use client"

import { useState } from "react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { toast } from "sonner"

interface ManualPaymentFormProps {
  unitId: string
  unitNumber: string
  onPaymentRecorded: () => void
}

export function ManualPaymentForm({ unitId, unitNumber, onPaymentRecorded }: ManualPaymentFormProps) {
  const [amountDollars, setAmountDollars] = useState("")
  const [method, setMethod] = useState<"cash" | "check" | "venmo" | "other">("cash")
  const [note, setNote] = useState("")
  const [saving, setSaving] = useState(false)
  const [open, setOpen] = useState(false)

  const billingPeriod = new Date().toISOString().slice(0, 7)

  async function handleSubmit() {
    const cents = Math.round(parseFloat(amountDollars) * 100)
    if (isNaN(cents) || cents <= 0) {
      toast.error("Enter a valid amount")
      return
    }

    setSaving(true)
    try {
      const res = await fetch("/api/payments/manual", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          unitId,
          amountCents: cents,
          paymentMethod: method,
          billingPeriod,
          note: note || undefined,
        }),
      })

      if (!res.ok) {
        const data = await res.json()
        toast.error(data.error || "Failed to record payment")
        return
      }

      toast.success(`Manual payment recorded for Unit ${unitNumber}`)
      setAmountDollars("")
      setNote("")
      setOpen(false)
      onPaymentRecorded()
    } catch {
      toast.error("Failed to record payment")
    } finally {
      setSaving(false)
    }
  }

  if (!open) {
    return (
      <Button variant="outline" size="sm" onClick={() => setOpen(true)}>
        Record Payment
      </Button>
    )
  }

  return (
    <div className="border rounded-lg p-3 bg-gray-50 space-y-2">
      <p className="text-sm font-medium">Record Manual Payment — Unit {unitNumber}</p>
      <div className="flex items-center gap-2">
        <div className="flex items-center gap-1">
          <span className="text-sm text-gray-500">$</span>
          <Input
            type="number"
            step="0.01"
            min="0"
            value={amountDollars}
            onChange={(e) => setAmountDollars(e.target.value)}
            className="w-28"
            placeholder="1500.00"
          />
        </div>
        <select
          value={method}
          onChange={(e) => setMethod(e.target.value as typeof method)}
          className="rounded-md border px-2 py-1.5 text-sm"
        >
          <option value="cash">Cash</option>
          <option value="check">Check</option>
          <option value="venmo">Venmo</option>
          <option value="other">Other</option>
        </select>
      </div>
      <Input
        value={note}
        onChange={(e) => setNote(e.target.value)}
        placeholder="Note (optional)"
        className="text-sm"
      />
      <div className="flex gap-2">
        <Button size="sm" onClick={handleSubmit} disabled={saving}>
          {saving ? "Saving..." : "Save"}
        </Button>
        <Button size="sm" variant="outline" onClick={() => setOpen(false)}>
          Cancel
        </Button>
      </div>
    </div>
  )
}
```

Step 3 — Create src/components/admin/PaymentDashboard.tsx (client component for month navigation):

```typescript
"use client"

import { useState, useEffect, useCallback } from "react"
import { Button } from "@/components/ui/button"
import { ManualPaymentForm } from "./ManualPaymentForm"

interface UnitPaymentStatus {
  unitId: string
  unitNumber: string
  propertyName: string
  tenantName: string | null
  tenantEmail: string | null
  rentAmountCents: number | null
  amountPaidCents: number
  status: "paid" | "unpaid" | "partial" | "pending"
  lastPaymentDate: string | null
}

export function PaymentDashboard({ initialData, initialPeriod }: {
  initialData: UnitPaymentStatus[]
  initialPeriod: string
}) {
  const [period, setPeriod] = useState(initialPeriod)
  const [data, setData] = useState(initialData)
  const [loading, setLoading] = useState(false)

  const fetchData = useCallback(async (p: string) => {
    setLoading(true)
    try {
      const res = await fetch(`/api/admin/payments-overview?period=${p}`)
      if (res.ok) {
        const json = await res.json()
        setData(json.units)
      }
    } finally {
      setLoading(false)
    }
  }, [])

  function navigateMonth(delta: number) {
    const [year, month] = period.split("-").map(Number)
    const d = new Date(year, month - 1 + delta, 1)
    const newPeriod = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, "0")}`
    setPeriod(newPeriod)
    fetchData(newPeriod)
  }

  const statusStyles: Record<string, string> = {
    paid: "bg-green-100 text-green-800",
    unpaid: "bg-red-100 text-red-800",
    partial: "bg-amber-100 text-amber-800",
    pending: "bg-yellow-100 text-yellow-800",
  }

  const periodLabel = new Date(period + "-01").toLocaleDateString("en-US", { month: "long", year: "numeric" })

  return (
    <div>
      {/* Month Navigation */}
      <div className="flex items-center gap-4 mb-6">
        <Button variant="outline" size="sm" onClick={() => navigateMonth(-1)}>
          Previous
        </Button>
        <span className="text-lg font-semibold">{periodLabel}</span>
        <Button variant="outline" size="sm" onClick={() => navigateMonth(1)}>
          Next
        </Button>
      </div>

      {/* Status Table */}
      {loading ? (
        <div className="text-center py-8 text-gray-500">Loading...</div>
      ) : (
        <table className="w-full border-collapse">
          <thead>
            <tr className="border-b text-left text-sm font-medium text-gray-500">
              <th className="pb-3 pr-4">Unit</th>
              <th className="pb-3 pr-4">Tenant</th>
              <th className="pb-3 pr-4">Amount Due</th>
              <th className="pb-3 pr-4">Amount Paid</th>
              <th className="pb-3 pr-4">Status</th>
              <th className="pb-3 pr-4">Last Payment</th>
              <th className="pb-3">Actions</th>
            </tr>
          </thead>
          <tbody>
            {data.map((unit) => (
              <tr key={unit.unitId} className="border-b">
                <td className="py-3 pr-4 font-medium">{unit.unitNumber}</td>
                <td className="py-3 pr-4 text-gray-600">
                  {unit.tenantName || unit.tenantEmail || <span className="text-gray-400">No tenant</span>}
                </td>
                <td className="py-3 pr-4">
                  {unit.rentAmountCents != null
                    ? `$${(unit.rentAmountCents / 100).toFixed(2)}`
                    : <span className="text-gray-400">Not set</span>}
                </td>
                <td className="py-3 pr-4 font-medium">
                  ${(unit.amountPaidCents / 100).toFixed(2)}
                </td>
                <td className="py-3 pr-4">
                  <span className={`inline-flex items-center rounded-full px-2 py-0.5 text-xs font-medium ${statusStyles[unit.status]}`}>
                    {unit.status.charAt(0).toUpperCase() + unit.status.slice(1)}
                  </span>
                </td>
                <td className="py-3 pr-4 text-sm text-gray-500">
                  {unit.lastPaymentDate || "—"}
                </td>
                <td className="py-3">
                  {unit.tenantName || unit.tenantEmail ? (
                    <ManualPaymentForm
                      unitId={unit.unitId}
                      unitNumber={unit.unitNumber}
                      onPaymentRecorded={() => fetchData(period)}
                    />
                  ) : null}
                </td>
              </tr>
            ))}
            {data.length === 0 && (
              <tr>
                <td colSpan={7} className="py-8 text-center text-gray-500">
                  No units found.
                </td>
              </tr>
            )}
          </tbody>
        </table>
      )}
    </div>
  )
}
```
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && npm run build 2>&1 | tail -5</automated>
  </verify>
  <done>
    ManualPaymentForm records offline payments via POST /api/payments/manual. PaymentDashboard shows per-unit status table with color-coded badges, month navigation, and inline manual payment recording. All components type-safe and handle empty states.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create admin payments overview API and page</name>
  <files>
    src/app/api/admin/payments-overview/route.ts
    src/app/(admin)/admin/payments/page.tsx
    src/app/(admin)/admin/dashboard/page.tsx
  </files>
  <action>
Step 1 — Create src/app/api/admin/payments-overview/route.ts:

```typescript
import { NextResponse } from "next/server"
import { auth } from "@/lib/auth"
import { headers } from "next/headers"
import { db } from "@/db"
import { units, properties, tenantUnits, payments } from "@/db/schema"
import { eq, and, sql } from "drizzle-orm"

export async function GET(req: Request) {
  const session = await auth.api.getSession({ headers: await headers() })
  if (!session || session.user.role !== "admin") {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
  }

  const url = new URL(req.url)
  const period = url.searchParams.get("period") || new Date().toISOString().slice(0, 7)

  // Get all units with their property, active tenant, and payment totals for the period
  // This is a complex query — we'll use a combination of Drizzle queries

  // 1. Get all units with properties
  const allUnits = await db
    .select({
      unitId: units.id,
      unitNumber: units.unitNumber,
      propertyName: properties.name,
      rentAmountCents: units.rentAmountCents,
    })
    .from(units)
    .innerJoin(properties, eq(units.propertyId, properties.id))
    .orderBy(units.unitNumber)

  // 2. Get active tenant links
  const activeTenants = await db
    .select({
      unitId: tenantUnits.unitId,
      userId: tenantUnits.userId,
    })
    .from(tenantUnits)
    .where(eq(tenantUnits.isActive, true))

  // 3. Get payment totals per unit for the period
  const periodPayments = await db
    .select({
      unitId: payments.unitId,
      totalPaidCents: sql<number>`COALESCE(SUM(CASE WHEN ${payments.status} IN ('succeeded', 'pending') THEN ${payments.amountCents} ELSE 0 END), 0)`.as("total_paid_cents"),
      lastPaymentDate: sql<string>`MAX(${payments.paidAt})`.as("last_payment_date"),
      hasPending: sql<boolean>`BOOL_OR(${payments.status} = 'pending')`.as("has_pending"),
    })
    .from(payments)
    .where(eq(payments.billingPeriod, period))
    .groupBy(payments.unitId)

  // 4. Get user names/emails for active tenants
  const tenantUserIds = activeTenants.map(t => t.userId)
  let userMap: Record<string, { name: string | null; email: string }> = {}
  if (tenantUserIds.length > 0) {
    const userIds = tenantUserIds.map(id => `'${id}'`).join(",")
    const usersResult = await db.execute(
      `SELECT id, name, email FROM "user" WHERE id IN (${userIds})`
    )
    const users = (usersResult as unknown as { rows: Array<{ id: string; name: string | null; email: string }> }).rows
    for (const u of users) {
      userMap[u.id] = { name: u.name, email: u.email }
    }
  }

  // 5. Combine into response
  const tenantByUnit = new Map(activeTenants.map(t => [t.unitId, t.userId]))
  const paymentByUnit = new Map(periodPayments.map(p => [p.unitId, p]))

  const result = allUnits.map(unit => {
    const tenantUserId = tenantByUnit.get(unit.unitId)
    const user = tenantUserId ? userMap[tenantUserId] : null
    const paymentData = paymentByUnit.get(unit.unitId)
    const amountPaid = paymentData?.totalPaidCents ?? 0
    const hasPending = paymentData?.hasPending ?? false

    let status: "paid" | "unpaid" | "partial" | "pending" = "unpaid"
    if (hasPending && amountPaid === 0) {
      status = "pending"
    } else if (unit.rentAmountCents && amountPaid >= unit.rentAmountCents) {
      status = "paid"
    } else if (amountPaid > 0) {
      status = hasPending ? "pending" : "partial"
    }

    return {
      unitId: unit.unitId,
      unitNumber: unit.unitNumber,
      propertyName: unit.propertyName,
      tenantName: user?.name || null,
      tenantEmail: user?.email || null,
      rentAmountCents: unit.rentAmountCents,
      amountPaidCents: amountPaid,
      status,
      lastPaymentDate: paymentData?.lastPaymentDate
        ? new Date(paymentData.lastPaymentDate).toLocaleDateString()
        : null,
    }
  })

  return NextResponse.json({ units: result, period })
}
```

NOTE: Status logic:
- "paid" = total succeeded+pending payments >= rent amount
- "partial" = some payment but less than rent amount
- "pending" = only pending (ACH) payments, no succeeded
- "unpaid" = no payments at all for the period

Step 2 — Create src/app/(admin)/admin/payments/page.tsx:

```typescript
import { auth } from "@/lib/auth"
import { headers } from "next/headers"
import { PaymentDashboard } from "@/components/admin/PaymentDashboard"

export default async function AdminPaymentsPage() {
  const session = await auth.api.getSession({ headers: await headers() })
  if (!session) return null

  const currentPeriod = new Date().toISOString().slice(0, 7)

  // Fetch initial data server-side
  const baseUrl = process.env.BETTER_AUTH_URL || "http://localhost:3000"
  let initialData = []
  try {
    const res = await fetch(`${baseUrl}/api/admin/payments-overview?period=${currentPeriod}`, {
      headers: { cookie: (await headers()).get("cookie") || "" },
    })
    if (res.ok) {
      const json = await res.json()
      initialData = json.units
    }
  } catch {
    // Fall back to empty — client will re-fetch
  }

  return (
    <div>
      <h1 className="text-2xl font-bold text-gray-900">Payment Dashboard</h1>
      <p className="mt-2 text-gray-600">
        View payment status for all units. Record manual payments for cash, check, or Venmo.
      </p>
      <div className="mt-6">
        <PaymentDashboard initialData={initialData} initialPeriod={currentPeriod} />
      </div>
    </div>
  )
}
```

Step 3 — Update src/app/(admin)/admin/dashboard/page.tsx to add a Payment Dashboard link. Add after existing links:

```tsx
<Link
  href="/admin/payments"
  className="inline-flex items-center rounded-md bg-gray-100 px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-200"
>
  Payment Dashboard
</Link>
```

Ensure the dashboard page has links to: View Users, Manage Units (from Plan 02), Manage Invites, and Payment Dashboard.
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && npm run build 2>&1 | tail -5</automated>
  </verify>
  <done>
    GET /api/admin/payments-overview returns per-unit payment status for a given billing period. Admin payments page at /admin/payments shows color-coded status table with month navigation. Manual payment recording works inline. Admin dashboard has navigation link to payment dashboard. npm run build passes.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npm run build` passes
2. /admin/payments shows per-unit payment status for current month
3. Status badges are color-coded: Paid (green), Unpaid (red), Partial (amber), Pending (yellow)
4. Month navigation works (previous/next)
5. Record Payment button opens inline form for manual payment
6. Manual payments create records with status "succeeded" immediately
7. Admin dashboard has link to payment dashboard
</verification>

<success_criteria>
- Admin payment dashboard shows per-unit paid/unpaid status for current period at a glance
- Color-coded status badges (Paid/Unpaid/Partial/Pending)
- Columns: unit, tenant name, amount due, amount paid, status badge, last payment date
- Default view: current calendar month with option to navigate to past months
- Admin can record manual/offline payments (cash, check, Venmo) with a note
</success_criteria>

<output>
After completion, create `.planning/phases/03-payments/03-05-SUMMARY.md`
</output>
