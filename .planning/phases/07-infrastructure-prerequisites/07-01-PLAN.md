---
phase: 07-infrastructure-prerequisites
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/index.ts
  - package.json
autonomous: true
requirements: [INFRA-04]

must_haves:
  truths:
    - "db.transaction() executes multi-statement operations atomically (both succeed or both roll back)"
    - "All existing database queries (selects, inserts, updates) continue to work unchanged after the driver swap"
    - "Better Auth login, session validation, and signup flows work correctly with the new driver"
    - "The Pool uses the -pooler connection string for PgBouncer connection management"
  artifacts:
    - path: "src/db/index.ts"
      provides: "Neon WebSocket Pool-based Drizzle database instance"
      contains: "Pool"
      exports: ["db"]
    - path: "package.json"
      provides: "ws and @types/ws dependencies"
      contains: "ws"
  key_links:
    - from: "src/db/index.ts"
      to: "@neondatabase/serverless"
      via: "Pool import (not neon HTTP)"
      pattern: "Pool.*@neondatabase/serverless"
    - from: "src/db/index.ts"
      to: "drizzle-orm/neon-serverless"
      via: "drizzle adapter import"
      pattern: "drizzle-orm/neon-serverless"
    - from: "src/lib/auth.ts"
      to: "src/db/index.ts"
      via: "import { db } from @/db"
      pattern: "import.*db.*from.*@/db"
---

<objective>
Swap the Neon HTTP database driver to the WebSocket-based neon-serverless driver to enable `db.transaction()` for atomic multi-table operations.

Purpose: The current HTTP driver (`neon()` + `drizzle-orm/neon-http`) cannot execute `db.transaction()`. The financial ledger in Phase 8 requires atomic multi-table inserts (charge + balance update). This is the #1 technical blocker for all subsequent v2.0 work.

Output: A working database connection using `Pool` from `@neondatabase/serverless` with `drizzle-orm/neon-serverless`, preserving the lazy-init Proxy pattern for build safety.
</objective>

<execution_context>
@/Users/odesantos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/odesantos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/07-infrastructure-prerequisites/07-RESEARCH.md

<interfaces>
<!-- Current src/db/index.ts — this is the file being replaced -->
From src/db/index.ts:
```typescript
import { neon } from "@neondatabase/serverless"
import { drizzle, NeonHttpDatabase } from "drizzle-orm/neon-http"
import * as schema from "./schema"

let _db: NeonHttpDatabase<typeof schema> | null = null

function getDb(): NeonHttpDatabase<typeof schema> {
  if (!_db) {
    const databaseUrl = process.env.DATABASE_URL
    if (!databaseUrl) {
      throw new Error("DATABASE_URL is not set...")
    }
    const sql = neon(databaseUrl)
    _db = drizzle({ client: sql, schema })
  }
  return _db
}

export const db = new Proxy({} as NeonHttpDatabase<typeof schema>, {
  get(_target, prop, receiver) {
    return Reflect.get(getDb(), prop, receiver)
  },
})

export type DB = NeonHttpDatabase<typeof schema>
```

From src/lib/auth.ts (consumer — imports db):
```typescript
import { db } from "@/db"
// ...
export const auth = betterAuth({
  database: drizzleAdapter(db, { provider: "pg", schema }),
  // ...
})
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install ws polyfill and swap database driver</name>
  <files>package.json, src/db/index.ts</files>
  <action>
1. Install WebSocket polyfill for Node.js v20 (project uses v20.12.0; native WebSocket only in v22+):
   ```bash
   npm install ws
   npm install -D @types/ws
   ```

2. Rewrite `src/db/index.ts` to use the neon-serverless WebSocket driver:

   Replace the ENTIRE file. The new implementation must:

   a. Import `Pool` and `neonConfig` from `@neondatabase/serverless` (NOT `neon` function)
   b. Import `drizzle` from `drizzle-orm/neon-serverless` (NOT `drizzle-orm/neon-http`)
   c. Import `ws` and set `neonConfig.webSocketConstructor = ws` (required for Node.js < v22)
   d. Import `* as schema` from `./schema`
   e. Create a singleton `Pool` with lazy initialization (same pattern as current code — only create when first accessed, not at import time)
   f. Use `drizzle({ client: getPool(), schema })` to create the Drizzle instance
   g. Preserve the Proxy pattern so Next.js build doesn't require DATABASE_URL at build time
   h. Export `db` (same name, same Proxy export) and `DB` type

   **CRITICAL details:**
   - The DATABASE_URL should use the `-pooler` hostname suffix for PgBouncer connection pooling. The code should NOT modify the URL — the user's .env.local should already have the pooler URL. Add a code comment noting this.
   - The Pool is a module-level singleton, NOT created per-request.
   - Remove ALL imports from `drizzle-orm/neon-http` and remove the `neon()` function call. The entire application must use one driver.
   - The `NeonHttpDatabase` type is replaced by the type from `drizzle-orm/neon-serverless`. Use `NeonDatabase` or infer from drizzle return type.
   - Do NOT change how `db` is used anywhere else. The consumer interface (db.select, db.insert, db.query, etc.) remains identical. The only new capability is `db.transaction()`.

3. Verify no remaining imports from `drizzle-orm/neon-http` anywhere in the codebase:
   ```bash
   grep -r "drizzle-orm/neon-http" src/ --include="*.ts" --include="*.tsx"
   ```
   This should return zero results.
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && grep -r "drizzle-orm/neon-http" src/ --include="*.ts" --include="*.tsx" | wc -l | tr -d ' ' | grep -q '^0$' && echo "PASS: no neon-http imports remain" || echo "FAIL: neon-http imports still exist"</automated>
  </verify>
  <done>src/db/index.ts uses Pool from @neondatabase/serverless with drizzle-orm/neon-serverless adapter. ws polyfill configured. No neon-http imports remain in codebase. Proxy lazy-init pattern preserved.</done>
</task>

<task type="auto">
  <name>Task 2: Verify driver swap with transaction test and auth flows</name>
  <files>e2e/infra-transactions.spec.ts</files>
  <action>
1. Start the dev server (if not running) and verify the application starts without errors.

2. Create an E2E test file `e2e/infra-transactions.spec.ts` that verifies:

   a. **Basic query works:** Log in as admin (use seed credentials from existing E2E tests — check `e2e/` for login patterns). Navigate to admin dashboard. If the page loads with data, basic selects work.

   b. **Auth flow works:** Log in as tenant, verify session persists (refresh page, still logged in). This proves Better Auth's drizzleAdapter works with the new driver.

   c. **Transaction capability exists:** Create a simple API test route or use an existing API route that performs a multi-step operation. Since we can't easily test rollback via E2E, verify that the driver swap doesn't break existing multi-query operations (e.g., submitting a maintenance request with photos — this does INSERT maintenance_request then INSERT maintenance_photos, which in a future phase will be wrapped in a transaction).

   Look at existing E2E test patterns in `e2e/` directory for login helpers, base URL config, and test structure. Follow the same patterns.

   **Important:** The test should verify the application works end-to-end with the new driver, not test transaction rollback specifically (that's an integration test concern for Phase 8).

3. Run the test:
   ```bash
   npx playwright test e2e/infra-transactions.spec.ts
   ```
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && npx playwright test e2e/infra-transactions.spec.ts</automated>
  </verify>
  <done>E2E test passes: admin login + dashboard load works, tenant login + session persistence works. The neon-serverless driver is fully operational for all existing query patterns.</done>
</task>

</tasks>

<verification>
1. `grep -r "drizzle-orm/neon-http" src/` returns zero results
2. `npm run build` completes without errors (driver swap doesn't break build)
3. `npx playwright test e2e/infra-transactions.spec.ts` passes
4. Dev server starts and admin/tenant flows work
</verification>

<success_criteria>
- Database driver is swapped from neon-http to neon-serverless with Pool
- `db.transaction()` is available (used in Phase 8, verified by type system)
- All existing queries and auth flows work unchanged
- No regression in application functionality
</success_criteria>

<output>
After completion, create `.planning/phases/07-infrastructure-prerequisites/07-01-SUMMARY.md`
</output>
