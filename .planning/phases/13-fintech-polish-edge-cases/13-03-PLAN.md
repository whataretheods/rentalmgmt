---
phase: 13-fintech-polish-edge-cases
plan: 03
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - src/app/api/admin/work-orders/[id]/costs/route.ts
  - src/app/api/webhooks/stripe/route.ts
  - src/lib/nsf.ts
  - src/lib/chargeback.ts
  - src/lib/__tests__/nsf-fee.test.ts
  - src/lib/__tests__/chargeback.test.ts
autonomous: true
requirements:
  - FIN-04
  - FIN-05

must_haves:
  truths:
    - "When admin adds a work order cost with billToTenant=true, a one_time charge is posted to the tenant's ledger"
    - "The chargeback charge description includes the work order cost description (e.g., 'Work order cost: Plumbing repair')"
    - "When a payment_intent.payment_failed event fires with metadata, an NSF fee charge is posted if NSF_FEE_CENTS env var is set"
    - "When checkout.session.async_payment_failed event fires with metadata, an NSF fee charge is posted if NSF_FEE_CENTS env var is set"
    - "NSF fees are NOT posted when NSF_FEE_CENTS is 0 or unset"
    - "NSF fees are NOT posted when tenantUserId/unitId metadata is missing"
  artifacts:
    - path: "src/app/api/admin/work-orders/[id]/costs/route.ts"
      provides: "Cost POST handler calling resolveAndPostChargeback"
      exports: ["POST", "GET", "DELETE"]
    - path: "src/app/api/webhooks/stripe/route.ts"
      provides: "Webhook calling postNsfFee on payment_failed and async_payment_failed"
      exports: ["POST"]
    - path: "src/lib/nsf.ts"
      provides: "Extracted postNsfFee helper"
      exports: ["postNsfFee"]
    - path: "src/lib/chargeback.ts"
      provides: "Extracted resolveAndPostChargeback helper"
      exports: ["resolveAndPostChargeback"]
    - path: "src/lib/__tests__/nsf-fee.test.ts"
      provides: "Unit tests for postNsfFee with mocked db.insert"
      min_lines: 30
    - path: "src/lib/__tests__/chargeback.test.ts"
      provides: "Unit tests for resolveAndPostChargeback with mocked db"
      min_lines: 25
  key_links:
    - from: "src/app/api/admin/work-orders/[id]/costs/route.ts"
      to: "src/lib/chargeback.ts"
      via: "import { resolveAndPostChargeback }"
      pattern: "resolveAndPostChargeback"
    - from: "src/lib/chargeback.ts"
      to: "src/db/schema/domain.ts"
      via: "import { charges, maintenanceRequests, workOrders }"
      pattern: "charges.*maintenanceRequests"
    - from: "src/app/api/webhooks/stripe/route.ts"
      to: "src/lib/nsf.ts"
      via: "import { postNsfFee }"
      pattern: "postNsfFee"
    - from: "src/lib/nsf.ts"
      to: "src/db/schema/domain.ts"
      via: "import { charges }"
      pattern: "charges"
---

<objective>
Add work order cost chargeback (bill-to-tenant) capability and NSF (non-sufficient funds) fee posting on failed payments.

Purpose: Landlords need to charge tenants for maintenance work (e.g., tenant-caused damage repairs). When ACH payments bounce, the landlord incurs bank fees that should be passed to the tenant. Both are standard property management financial operations.

Output: Updated work order cost endpoint with billToTenant toggle, webhook handler with NSF fee logic.
</objective>

<execution_context>
@/Users/odesantos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/odesantos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/13-fintech-polish-edge-cases/13-RESEARCH.md

@src/app/api/admin/work-orders/[id]/costs/route.ts
@src/app/api/webhooks/stripe/route.ts
@src/db/schema/domain.ts

<interfaces>
<!-- Key schema and types the executor needs -->

From src/db/schema/domain.ts:
```typescript
export const charges = pgTable("charges", {
  id: uuid("id").primaryKey().defaultRandom(),
  tenantUserId: text("tenant_user_id").notNull(),
  unitId: uuid("unit_id").references(() => units.id, { onDelete: "restrict" }).notNull(),
  type: text("type", { enum: ["rent", "late_fee", "one_time", "credit", "adjustment"] }).notNull(),
  description: text("description").notNull(),
  amountCents: integer("amount_cents").notNull(),
  billingPeriod: text("billing_period"),
  createdBy: text("created_by"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
})

export const workOrders = pgTable("work_orders", {
  id: uuid("id").primaryKey().defaultRandom(),
  maintenanceRequestId: uuid("maintenance_request_id").references(() => maintenanceRequests.id).notNull(),
  // ...
})

export const maintenanceRequests = pgTable("maintenance_requests", {
  id: uuid("id").primaryKey().defaultRandom(),
  tenantUserId: text("tenant_user_id").notNull(),
  unitId: uuid("unit_id").references(() => units.id).notNull(),
  // ...
})
```

Chargeback data chain (from research):
```
workOrderCost -> workOrder -> maintenanceRequest -> (tenantUserId, unitId)
```

NSF metadata available on payment intents:
```typescript
paymentIntent.metadata: { tenantUserId, unitId, billingPeriod, autopay }
```

NSF metadata available on checkout sessions:
```typescript
session.metadata: { tenantUserId, unitId, billingPeriod }
```
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Extract chargeback helper and add billToTenant to work order costs</name>
  <files>src/lib/chargeback.ts, src/lib/__tests__/chargeback.test.ts, src/app/api/admin/work-orders/[id]/costs/route.ts</files>
  <action>
    **Step 1: Create src/lib/chargeback.ts with resolveAndPostChargeback**
    Extract the chargeback resolve-and-post logic into a testable helper:
    ```typescript
    import { db } from "@/db"
    import { charges, maintenanceRequests, workOrders } from "@/db/schema"
    import { eq } from "drizzle-orm"

    /**
     * Resolve tenant from work order -> maintenance request chain
     * and post a one_time charge to their ledger.
     * Returns true if a charge was posted, false if tenant could not be resolved.
     */
    export async function resolveAndPostChargeback(
      workOrderId: string,
      description: string,
      amountCents: number,
      createdBy: string
    ): Promise<boolean> {
      const [maintReq] = await db
        .select({
          tenantUserId: maintenanceRequests.tenantUserId,
          unitId: maintenanceRequests.unitId,
        })
        .from(maintenanceRequests)
        .innerJoin(workOrders, eq(workOrders.maintenanceRequestId, maintenanceRequests.id))
        .where(eq(workOrders.id, workOrderId))

      if (!maintReq) return false

      await db.insert(charges).values({
        tenantUserId: maintReq.tenantUserId,
        unitId: maintReq.unitId,
        type: "one_time",
        description: `Work order cost: ${description.trim()}`,
        amountCents,
        createdBy,
      })
      return true
    }
    ```

    **Step 2: RED — Write tests in src/lib/__tests__/chargeback.test.ts**
    ```typescript
    import { describe, it, expect, vi, beforeEach } from "vitest"

    // Mock db module
    const mockSelect = vi.fn()
    const mockInsert = vi.fn()
    vi.mock("@/db", () => ({
      db: {
        select: (...args: unknown[]) => mockSelect(...args),
        insert: (...args: unknown[]) => mockInsert(...args),
      },
    }))
    vi.mock("@/db/schema", () => ({
      charges: Symbol("charges"),
      maintenanceRequests: { tenantUserId: "tenantUserId", unitId: "unitId" },
      workOrders: { maintenanceRequestId: "maintenanceRequestId", id: "id" },
    }))
    vi.mock("drizzle-orm", () => ({ eq: vi.fn() }))

    import { resolveAndPostChargeback } from "../chargeback"

    describe("resolveAndPostChargeback", () => {
      beforeEach(() => { vi.clearAllMocks() })

      it("posts a one_time charge when maintenance request is found", async () => {
        // Setup: select chain returns tenant info
        const fromMock = vi.fn().mockReturnValue({
          innerJoin: vi.fn().mockReturnValue({
            where: vi.fn().mockResolvedValue([{ tenantUserId: "t1", unitId: "u1" }]),
          }),
        })
        mockSelect.mockReturnValue({ from: fromMock })
        mockInsert.mockReturnValue({ values: vi.fn().mockResolvedValue(undefined) })

        const result = await resolveAndPostChargeback("wo1", "Plumbing repair", 5000, "admin1")
        expect(result).toBe(true)
        expect(mockInsert).toHaveBeenCalled()
      })

      it("returns false when maintenance request not found", async () => {
        const fromMock = vi.fn().mockReturnValue({
          innerJoin: vi.fn().mockReturnValue({
            where: vi.fn().mockResolvedValue([]),
          }),
        })
        mockSelect.mockReturnValue({ from: fromMock })

        const result = await resolveAndPostChargeback("wo-none", "Test", 1000, "admin1")
        expect(result).toBe(false)
        expect(mockInsert).not.toHaveBeenCalled()
      })

      it("includes description in charge text", async () => {
        const valuesMock = vi.fn().mockResolvedValue(undefined)
        const fromMock = vi.fn().mockReturnValue({
          innerJoin: vi.fn().mockReturnValue({
            where: vi.fn().mockResolvedValue([{ tenantUserId: "t1", unitId: "u1" }]),
          }),
        })
        mockSelect.mockReturnValue({ from: fromMock })
        mockInsert.mockReturnValue({ values: valuesMock })

        await resolveAndPostChargeback("wo1", "  Broken window  ", 8000, "admin1")
        expect(valuesMock).toHaveBeenCalledWith(
          expect.objectContaining({ description: "Work order cost: Broken window" })
        )
      })
    })
    ```

    Run `npx vitest run src/lib/__tests__/chargeback.test.ts` — MUST PASS after Step 1.

    **Step 3: Update POST handler in src/app/api/admin/work-orders/[id]/costs/route.ts**
    - Add `billToTenant` to the destructured body
    - Import `resolveAndPostChargeback` from `@/lib/chargeback`
    - After cost insertion, when `billToTenant` is truthy, call:
      ```typescript
      let chargePosted = false
      if (billToTenant) {
        chargePosted = await resolveAndPostChargeback(id, description, amountCents, session.user.id)
      }
      ```
    - Return `chargePosted` in the response:
      ```typescript
      return NextResponse.json({ cost, chargePosted }, { status: 201 })
      ```

    **IMPORTANT per research:** Use the maintenance request's `tenantUserId` directly — NOT an active tenancy lookup. The charge goes to whoever filed the request, even if they've moved out. Use charge type `one_time` (not a new enum value) with a descriptive description.
  </action>
  <verify>
    <automated>npx vitest run src/lib/__tests__/chargeback.test.ts --reporter=verbose</automated>
  </verify>
  <done>resolveAndPostChargeback extracted to src/lib/chargeback.ts with unit tests. Work order cost POST handler calls it when billToTenant=true. 3+ chargeback test cases pass.</done>
</task>

<task type="auto" tdd="true">
  <name>Task 2: Extract postNsfFee to src/lib/nsf.ts and wire into webhook</name>
  <files>src/lib/nsf.ts, src/lib/__tests__/nsf-fee.test.ts, src/app/api/webhooks/stripe/route.ts</files>
  <action>
    **Step 1: Create src/lib/nsf.ts with extracted postNsfFee**
    ```typescript
    import { charges } from "@/db/schema"

    /**
     * Post an NSF (non-sufficient funds) fee charge to the tenant's ledger.
     * Reads NSF_FEE_CENTS from env. Returns true if a charge was posted.
     *
     * @param tx - A drizzle db instance or transaction
     * @param tenantUserId - Tenant user ID from payment metadata
     * @param unitId - Unit ID from payment metadata
     * @param billingPeriod - Optional billing period string
     */
    export async function postNsfFee(
      tx: { insert: (table: typeof charges) => { values: (v: Record<string, unknown>) => Promise<unknown> } },
      tenantUserId: string,
      unitId: string,
      billingPeriod?: string | null
    ): Promise<boolean> {
      const nsfFeeCents = parseInt(process.env.NSF_FEE_CENTS || "0", 10)
      if (nsfFeeCents <= 0) return false

      await tx.insert(charges).values({
        tenantUserId,
        unitId,
        type: "one_time",
        description: billingPeriod
          ? `NSF fee - returned payment for ${billingPeriod}`
          : "NSF fee - returned payment",
        amountCents: nsfFeeCents,
        billingPeriod: billingPeriod || null,
        createdBy: null, // system-generated
      })
      return true
    }
    ```

    **Step 2: RED — Write tests in src/lib/__tests__/nsf-fee.test.ts**
    Test the real `postNsfFee` function with mocked db.insert:
    ```typescript
    import { describe, it, expect, vi, beforeEach, afterEach } from "vitest"

    vi.mock("@/db/schema", () => ({
      charges: Symbol("charges"),
    }))

    import { postNsfFee } from "../nsf"

    describe("postNsfFee", () => {
      const originalEnv = process.env.NSF_FEE_CENTS

      beforeEach(() => { vi.clearAllMocks() })
      afterEach(() => {
        if (originalEnv !== undefined) process.env.NSF_FEE_CENTS = originalEnv
        else delete process.env.NSF_FEE_CENTS
      })

      function makeMockTx() {
        const valuesMock = vi.fn().mockResolvedValue(undefined)
        const insertMock = vi.fn().mockReturnValue({ values: valuesMock })
        return { insert: insertMock, valuesMock }
      }

      it("posts a charge when NSF_FEE_CENTS is set and positive", async () => {
        process.env.NSF_FEE_CENTS = "2500"
        const { insert, valuesMock } = makeMockTx()
        const result = await postNsfFee({ insert }, "t1", "u1", "2026-03")
        expect(result).toBe(true)
        expect(valuesMock).toHaveBeenCalledWith(
          expect.objectContaining({ amountCents: 2500, tenantUserId: "t1", unitId: "u1" })
        )
      })

      it("returns false when NSF_FEE_CENTS is 0", async () => {
        process.env.NSF_FEE_CENTS = "0"
        const { insert } = makeMockTx()
        const result = await postNsfFee({ insert }, "t1", "u1")
        expect(result).toBe(false)
        expect(insert).not.toHaveBeenCalled()
      })

      it("returns false when NSF_FEE_CENTS is unset", async () => {
        delete process.env.NSF_FEE_CENTS
        const { insert } = makeMockTx()
        const result = await postNsfFee({ insert }, "t1", "u1")
        expect(result).toBe(false)
        expect(insert).not.toHaveBeenCalled()
      })

      it("includes billing period in description when available", async () => {
        process.env.NSF_FEE_CENTS = "2500"
        const { insert, valuesMock } = makeMockTx()
        await postNsfFee({ insert }, "t1", "u1", "2026-03")
        expect(valuesMock).toHaveBeenCalledWith(
          expect.objectContaining({ description: "NSF fee - returned payment for 2026-03" })
        )
      })

      it("uses generic description when billing period is missing", async () => {
        process.env.NSF_FEE_CENTS = "2500"
        const { insert, valuesMock } = makeMockTx()
        await postNsfFee({ insert }, "t1", "u1")
        expect(valuesMock).toHaveBeenCalledWith(
          expect.objectContaining({ description: "NSF fee - returned payment" })
        )
      })
    })
    ```

    Run `npx vitest run src/lib/__tests__/nsf-fee.test.ts` — MUST PASS after Step 1.

    **Step 3: Wire postNsfFee into webhook route**
    In `src/app/api/webhooks/stripe/route.ts`:
    - Add import: `import { postNsfFee } from "@/lib/nsf"`
    - In `payment_intent.payment_failed` handler, after `tx.update(payments)`:
      ```typescript
      const { tenantUserId, unitId, billingPeriod } = paymentIntent.metadata || {}
      if (tenantUserId && unitId) {
        await postNsfFee(tx, tenantUserId, unitId, billingPeriod)
      }
      ```
    - In `checkout.session.async_payment_failed` handler, after `tx.update(payments)`:
      ```typescript
      const { tenantUserId, unitId, billingPeriod } = session.metadata || {}
      if (tenantUserId && unitId) {
        await postNsfFee(tx, tenantUserId, unitId, billingPeriod)
      }
      ```

    **IMPORTANT per research (Pitfall 5):** NSF fees must be added to BOTH `payment_intent.payment_failed` (autopay) AND `checkout.session.async_payment_failed` (one-time ACH). Only post when metadata is present — some events may not carry tenant info.
  </action>
  <verify>
    <automated>npx vitest run src/lib/__tests__/nsf-fee.test.ts --reporter=verbose</automated>
  </verify>
  <done>postNsfFee extracted to src/lib/nsf.ts and unit-tested with mocked db.insert. Webhook route imports and calls it for both payment failure event types. 5 test cases pass covering fee posting, env var control, and description formatting.</done>
</task>

</tasks>

<verification>
1. `npx vitest run --reporter=verbose` — all unit tests pass
2. `grep -n "billToTenant" src/app/api/admin/work-orders/[id]/costs/route.ts` — confirms chargeback flag
3. `grep -n "postNsfFee" src/app/api/webhooks/stripe/route.ts` — confirms webhook imports and calls postNsfFee
4. `grep -n "resolveAndPostChargeback" src/app/api/admin/work-orders/[id]/costs/route.ts` — confirms route imports and calls chargeback helper
5. `grep -n "postNsfFee" src/lib/nsf.ts` — confirms extracted helper exists
6. `grep -n "resolveAndPostChargeback" src/lib/chargeback.ts` — confirms extracted helper exists
</verification>

<success_criteria>
- Work order cost POST accepts billToTenant flag and posts charge to tenant ledger
- Chargeback resolves tenant from maintenance request chain (not active tenancy)
- NSF fee logic in both payment_intent.payment_failed and checkout.session.async_payment_failed
- NSF fee controlled by NSF_FEE_CENTS env var (0 or unset = disabled)
- NSF fee only posted when tenant metadata is present
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/13-fintech-polish-edge-cases/13-03-SUMMARY.md`
</output>
