---
phase: 11-admin-ux-kpi-dashboard
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/kpi-queries.ts
  - src/components/admin/KpiCard.tsx
  - src/app/(admin)/admin/dashboard/page.tsx
autonomous: true
requirements: [AUX-02]

must_haves:
  truths:
    - "Admin dashboard displays a collection rate percentage derived from the ledger"
    - "Admin dashboard shows total outstanding balance in dollar format"
    - "Admin dashboard shows occupancy rate as a percentage"
    - "Admin dashboard shows count of open maintenance requests"
    - "Admin dashboard shows count of overdue tenants"
    - "All KPI values are computed from live database data, not hardcoded"
  artifacts:
    - path: "src/lib/kpi-queries.ts"
      provides: "Server-side KPI aggregation functions querying the live database"
      exports: ["getKpiMetrics"]
      min_lines: 60
    - path: "src/components/admin/KpiCard.tsx"
      provides: "Reusable KPI metric card component"
      min_lines: 20
    - path: "src/app/(admin)/admin/dashboard/page.tsx"
      provides: "Admin dashboard page rendering KPI cards with live data"
      min_lines: 40
  key_links:
    - from: "src/app/(admin)/admin/dashboard/page.tsx"
      to: "src/lib/kpi-queries.ts"
      via: "import and call getKpiMetrics()"
      pattern: "getKpiMetrics"
    - from: "src/app/(admin)/admin/dashboard/page.tsx"
      to: "src/components/admin/KpiCard.tsx"
      via: "renders KpiCard for each metric"
      pattern: "KpiCard"
    - from: "src/lib/kpi-queries.ts"
      to: "src/db"
      via: "Drizzle ORM queries against payments, units, tenantUnits, maintenanceRequests"
      pattern: "from.*db"
---

<objective>
Build the KPI dashboard with five metric cards showing collection rate, total outstanding balance, occupancy rate, open maintenance requests, and overdue tenants.

Purpose: Give the admin an at-a-glance view of portfolio health with metrics derived from live database data.
Output: KPI query functions, reusable card component, and data-driven dashboard page.
</objective>

<execution_context>
@/Users/odesantos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/odesantos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@src/db/schema/domain.ts
@src/db/index.ts
@src/components/ui/card.tsx

<interfaces>
<!-- Database schema tables used for KPI queries -->
From src/db/schema/domain.ts:
```typescript
export const units = pgTable("units", {
  id: uuid("id").primaryKey().defaultRandom(),
  propertyId: uuid("property_id").references(() => properties.id).notNull(),
  unitNumber: text("unit_number").notNull(),
  rentAmountCents: integer("rent_amount_cents"),
  rentDueDay: integer("rent_due_day"),
})

export const tenantUnits = pgTable("tenant_units", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: text("user_id").notNull(),
  unitId: uuid("unit_id").references(() => units.id).notNull(),
  isActive: boolean("is_active").default(true).notNull(),
})

export const payments = pgTable("payments", {
  id: uuid("id").primaryKey().defaultRandom(),
  tenantUserId: text("tenant_user_id").notNull(),
  unitId: uuid("unit_id").references(() => units.id).notNull(),
  amountCents: integer("amount_cents").notNull(),
  status: text("status", { enum: ["pending", "succeeded", "failed"] }).notNull(),
  billingPeriod: text("billing_period").notNull(),  // "2026-03" YYYY-MM
})

export const maintenanceRequests = pgTable("maintenance_requests", {
  id: uuid("id").primaryKey().defaultRandom(),
  status: text("status", { enum: ["submitted", "acknowledged", "in_progress", "resolved"] }),
})
```

From src/components/ui/card.tsx:
```typescript
export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
```

From src/db/index.ts:
```typescript
export const db  // Proxy-based lazy initialization, NeonHttpDatabase
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create KPI query functions and KpiCard component</name>
  <files>
    src/lib/kpi-queries.ts
    src/components/admin/KpiCard.tsx
  </files>
  <action>
**src/lib/kpi-queries.ts** — Server-side KPI aggregation:

Create a module with a single exported function `getKpiMetrics()` that returns all five KPI values. Use `Promise.all` to run independent queries in parallel for performance.

```typescript
import { db } from "@/db"
import { units, tenantUnits, payments, maintenanceRequests } from "@/db/schema"
import { eq, ne, and, sql } from "drizzle-orm"

export interface KpiMetrics {
  collectionRate: number       // percentage 0-100
  totalOutstandingCents: number // total unpaid amount in cents
  occupancyRate: number        // percentage 0-100
  openMaintenanceCount: number // count of non-resolved requests
  overdueTenantsCount: number  // count of tenants past due with no payment
}

export async function getKpiMetrics(): Promise<KpiMetrics> {
  const currentPeriod = new Date().toISOString().slice(0, 7) // "2026-02"
  const currentDay = new Date().getDate()

  const [occupancy, maintenance, collection] = await Promise.all([
    getOccupancyMetrics(),
    getMaintenanceMetrics(),
    getCollectionMetrics(currentPeriod, currentDay),
  ])

  return { ...occupancy, ...maintenance, ...collection }
}
```

Implement three helper functions (NOT exported, internal to module):

1. **`getOccupancyMetrics()`** — Returns `{ occupancyRate: number }`:
   - Query 1: `SELECT COUNT(*)::int` from `units` table → totalUnits
   - Query 2: `SELECT COUNT(DISTINCT unit_id)::int` from `tenant_units` where `is_active = true` → occupiedUnits
   - Calculate: `totalUnits > 0 ? Math.round((occupiedUnits / totalUnits) * 100) : 0`
   - Run both queries with `Promise.all` for parallelism

2. **`getMaintenanceMetrics()`** — Returns `{ openMaintenanceCount: number }`:
   - `SELECT COUNT(*)::int` from `maintenance_requests` where `status != 'resolved'`
   - Single query, straightforward

3. **`getCollectionMetrics(period: string, currentDay: number)`** — Returns `{ collectionRate, totalOutstandingCents, overdueTenantsCount }`:
   - This is the most complex query. Use a multi-step approach:

   Step A: Get all occupied units with rent configured:
   ```sql
   SELECT tu.unit_id, u.rent_amount_cents, u.rent_due_day
   FROM tenant_units tu
   INNER JOIN units u ON tu.unit_id = u.id
   WHERE tu.is_active = true AND u.rent_amount_cents IS NOT NULL
   ```

   Step B: Get payment totals per unit for current period:
   ```sql
   SELECT unit_id, COALESCE(SUM(amount_cents), 0) as total_paid
   FROM payments
   WHERE billing_period = $period AND status = 'succeeded'
   GROUP BY unit_id
   ```

   Step C: Compute metrics in JS from the two result sets:
   - Build a Map of unitId → totalPaid from step B
   - Iterate occupied units from step A:
     - `paidCount`: units where totalPaid >= rentAmountCents
     - `totalOutstandingCents`: sum of MAX(rentAmountCents - totalPaid, 0) across all occupied units
     - `overdueTenantsCount`: units where rentDueDay < currentDay AND totalPaid === 0
   - `collectionRate`: `occupiedWithRent > 0 ? Math.round((paidCount / occupiedWithRent) * 100) : 0`

   Run steps A and B with `Promise.all` for parallelism.

Important notes:
- Use Drizzle's `sql` template literal for raw SQL expressions (COUNT, SUM, COALESCE)
- All queries use the `db` import from `@/db`
- Cast counts with `::int` in PostgreSQL to avoid BigInt issues
- Handle edge cases: zero units (0% occupancy), zero occupied units (0% collection), no payments (100% outstanding)

**src/components/admin/KpiCard.tsx** — Reusable KPI display card:

```typescript
import { Card, CardContent } from "@/components/ui/card"
import { LucideIcon } from "lucide-react"

interface KpiCardProps {
  title: string
  value: string
  subtitle?: string
  icon: LucideIcon
  iconBgColor?: string  // e.g., "bg-blue-100"
  iconColor?: string    // e.g., "text-blue-600"
}
```

- This is a SERVER component (no "use client" needed) — it receives pre-formatted string values
- Render structure:
  - Card with no extra padding modifications
  - CardContent with `flex items-center gap-4` layout
  - Left: icon container with rounded-lg background using `iconBgColor` (default `bg-gray-100`) and `p-3`
  - Right: stack of title (text-sm font-medium text-gray-500), value (text-2xl font-bold text-gray-900), optional subtitle (text-xs text-gray-400 mt-0.5)
  - Icon rendered at `h-5 w-5` with `iconColor` (default `text-gray-600`)
  </action>
  <verify>
    <automated>
      cd /Users/odesantos/Documents/rentalmgmt && npx tsc --noEmit src/lib/kpi-queries.ts src/components/admin/KpiCard.tsx 2>&1 | head -20
    </automated>
  </verify>
  <done>KPI query module exports getKpiMetrics() returning all 5 metrics from live database. KpiCard component renders a formatted metric card.</done>
</task>

<task type="auto">
  <name>Task 2: Rebuild dashboard page with KPI cards</name>
  <files>
    src/app/(admin)/admin/dashboard/page.tsx
  </files>
  <action>
Replace the current placeholder dashboard page with a data-driven KPI dashboard.

The page is a **Server Component** (no "use client") — it fetches KPI data directly.

Add `export const dynamic = 'force-dynamic'` at the top to prevent stale cached data in production.

Import:
- `getKpiMetrics` from `@/lib/kpi-queries`
- `KpiCard` from `@/components/admin/KpiCard`
- Lucide icons: `DollarSign, TrendingUp, Building, Wrench, AlertTriangle` (one per KPI)

In the page component:
1. Call `const metrics = await getKpiMetrics()` — this runs server-side, no loading state needed
2. Format the values:
   - Collection rate: `${metrics.collectionRate}%`
   - Outstanding balance: Format cents to dollars using `new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(metrics.totalOutstandingCents / 100)`
   - Occupancy rate: `${metrics.occupancyRate}%`
   - Open maintenance: `${metrics.openMaintenanceCount}` (plain number)
   - Overdue tenants: `${metrics.overdueTenantsCount}` (plain number)

3. Render the page:
```tsx
<div className="space-y-6">
  <div>
    <h1 className="text-2xl font-bold text-gray-900">Dashboard</h1>
    <p className="mt-1 text-sm text-gray-600">
      Portfolio overview for {new Date().toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}
    </p>
  </div>

  {/* KPI Grid — 1 col on mobile, 2 on sm, 3 on lg */}
  <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">
    <KpiCard
      title="Collection Rate"
      value={formattedCollectionRate}
      subtitle="Current billing period"
      icon={TrendingUp}
      iconBgColor="bg-green-100"
      iconColor="text-green-600"
    />
    <KpiCard
      title="Total Outstanding"
      value={formattedOutstanding}
      subtitle="Unpaid rent this period"
      icon={DollarSign}
      iconBgColor="bg-red-100"
      iconColor="text-red-600"
    />
    <KpiCard
      title="Occupancy Rate"
      value={formattedOccupancy}
      subtitle="Units with active tenants"
      icon={Building}
      iconBgColor="bg-blue-100"
      iconColor="text-blue-600"
    />
    <KpiCard
      title="Open Requests"
      value={formattedMaintenance}
      subtitle="Unresolved maintenance"
      icon={Wrench}
      iconBgColor="bg-amber-100"
      iconColor="text-amber-600"
    />
    <KpiCard
      title="Overdue Tenants"
      value={formattedOverdue}
      subtitle="Past due day, no payment"
      icon={AlertTriangle}
      iconBgColor="bg-orange-100"
      iconColor="text-orange-600"
    />
  </div>

  {/* Quick links section below KPIs */}
  <div>
    <h2 className="text-lg font-semibold text-gray-900">Quick Actions</h2>
    <div className="mt-3 flex flex-wrap gap-3">
      {/* Keep the existing quick action links from current page */}
      <Link href="/admin/users" className="...">View Users</Link>
      <Link href="/admin/units" className="...">Manage Units</Link>
      <Link href="/admin/payments" className="...">Payment Dashboard</Link>
    </div>
  </div>
</div>
```

Keep the existing quick action links below the KPI grid with the same styling they currently have (bg-gray-100, hover:bg-gray-200, rounded-md, px-4, py-2, text-sm, font-medium, text-gray-700).

Do NOT add any client-side interactivity — the entire page is a Server Component that renders with data from the first paint.
  </action>
  <verify>
    <automated>
      cd /Users/odesantos/Documents/rentalmgmt && npx tsc --noEmit src/app/\(admin\)/admin/dashboard/page.tsx 2>&1 | head -20
    </automated>
  </verify>
  <done>Dashboard page displays 5 KPI cards with live data. Collection rate, outstanding balance, occupancy rate, open maintenance, and overdue tenants all computed from the database. No loading states — data renders on first paint via Server Component.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. Dashboard page loads and displays 5 KPI cards with computed values
3. KPI values reflect actual database state (not hardcoded)
4. Grid layout is responsive: 1 column on mobile, 2 on sm, 3 on lg
5. No loading spinners or skeleton states needed — Server Component renders with data
6. Quick action links preserved below KPI grid
</verification>

<success_criteria>
- Five KPI metric cards displayed on admin dashboard with data from the live database
- Collection rate shows percentage of units that have paid for current billing period
- Total outstanding shows dollar amount of unpaid rent for current period
- Occupancy rate shows percentage of units with active tenants
- Open maintenance shows count of unresolved maintenance requests
- Overdue tenants shows count of tenants past their due day with no payment
- All values update on page refresh to reflect current data
</success_criteria>

<output>
After completion, create `.planning/phases/11-admin-ux-kpi-dashboard/11-02-SUMMARY.md`
</output>
