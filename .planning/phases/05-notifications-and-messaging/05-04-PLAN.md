---
phase: 05-notifications-and-messaging
plan: 04
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/app/api/cron/rent-reminders/route.ts
  - src/emails/RentReminderEmail.tsx
autonomous: true
requirements:
  - NOTIF-01

must_haves:
  truths:
    - "Cron endpoint sends reminders 3-5 days before due date"
    - "Cron endpoint sends reminder on due date"
    - "Cron endpoint sends reminder when overdue (day 1, 3, 7 past due)"
    - "Reminders are idempotent -- duplicate cron runs do not send duplicate notifications"
    - "Reminders skip tenants who have already paid for the current billing period"
    - "Cron endpoint is protected by CRON_SECRET bearer token"
    - "Each reminder creates a notification record in the database"
  artifacts:
    - path: "src/app/api/cron/rent-reminders/route.ts"
      provides: "CRON_SECRET-protected POST endpoint for automated rent reminders"
      exports: ["POST"]
    - path: "src/emails/RentReminderEmail.tsx"
      provides: "Styled email template for rent reminders"
  key_links:
    - from: "src/app/api/cron/rent-reminders/route.ts"
      to: "src/lib/notifications.ts"
      via: "sendNotification for each tenant needing a reminder"
      pattern: "sendNotification"
    - from: "src/app/api/cron/rent-reminders/route.ts"
      to: "src/db/schema/domain.ts"
      via: "queries tenantUnits + units + payments + notifications"
      pattern: "(tenantUnits|units|payments|notifications)"
---

<objective>
Create the cron-triggered rent reminder API endpoint that sends automated reminders before due date, on due date, and when overdue -- with idempotency to prevent duplicate notifications.

Purpose: NOTIF-01 requires automated rent reminders at three stages. The cron endpoint queries all active tenant-unit links, checks due dates against today, and dispatches notifications via email, SMS, and in-app channels.

Output: CRON_SECRET-protected API route, styled email template for reminders.
</objective>

<execution_context>
@/Users/odesantos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/odesantos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-notifications-and-messaging/05-RESEARCH.md
@.planning/phases/05-notifications-and-messaging/05-01-SUMMARY.md

@src/db/schema/domain.ts
@src/lib/notifications.ts

<interfaces>
From src/db/schema/domain.ts:
```typescript
export const units = pgTable("units", {
  id: uuid("id").primaryKey().defaultRandom(),
  unitNumber: text("unit_number").notNull(),
  rentAmountCents: integer("rent_amount_cents"),
  rentDueDay: integer("rent_due_day"),
  // ...
})

export const tenantUnits = pgTable("tenant_units", {
  userId: text("user_id").notNull(),
  unitId: uuid("unit_id").notNull(),
  isActive: boolean("is_active").default(true).notNull(),
  // ...
})

export const payments = pgTable("payments", {
  tenantUserId: text("tenant_user_id").notNull(),
  unitId: uuid("unit_id").notNull(),
  amountCents: integer("amount_cents").notNull(),
  status: text("status", { enum: ["pending", "succeeded", "failed"] }).notNull(),
  billingPeriod: text("billing_period").notNull(),  // "YYYY-MM" format
  // ...
})

export const notifications = pgTable("notifications", {
  userId: text("user_id").notNull(),
  type: text("type", { enum: ["rent_reminder", ...] }).notNull(),
  title: text("title").notNull(),
  body: text("body").notNull(),
  channel: text("channel", { enum: ["in_app", "email", "sms"] }).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  // ...
})
```

From src/lib/notifications.ts:
```typescript
export async function sendNotification(payload: NotificationPayload): Promise<NotificationRecord>
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rent reminder cron API route</name>
  <files>src/app/api/cron/rent-reminders/route.ts</files>
  <action>
Create POST /api/cron/rent-reminders that:

1. Validates CRON_SECRET bearer token:
   ```typescript
   const authHeader = req.headers.get("authorization")
   if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
     return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
   }
   ```

2. Determines current date context:
   - `today = new Date()`
   - `currentDay = today.getDate()`
   - `currentPeriod = YYYY-MM format` (for idempotency checks)

3. Queries all active tenant-unit links with unit details:
   ```typescript
   const activeLinks = await db
     .select({
       userId: tenantUnits.userId,
       unitId: tenantUnits.unitId,
       unitNumber: units.unitNumber,
       rentAmountCents: units.rentAmountCents,
       rentDueDay: units.rentDueDay,
     })
     .from(tenantUnits)
     .innerJoin(units, eq(units.id, tenantUnits.unitId))
     .where(eq(tenantUnits.isActive, true))
   ```

4. For each active link, determines reminder type based on daysUntilDue:
   - `daysUntilDue = rentDueDay - currentDay`
   - If daysUntilDue is 3, 4, or 5: reminderType = "upcoming"
   - If daysUntilDue is 0: reminderType = "due_today"
   - If daysUntilDue is -1: reminderType = "overdue_1"
   - If daysUntilDue is -3: reminderType = "overdue_3"
   - If daysUntilDue is -7: reminderType = "overdue_7"
   - Otherwise: skip (no reminder needed today)

5. Idempotency check -- before sending, query the notifications table:
   ```typescript
   const existing = await db.select({ id: notifications.id })
     .from(notifications)
     .where(and(
       eq(notifications.userId, link.userId),
       eq(notifications.type, "rent_reminder"),
       sql`${notifications.title} LIKE ${`%${reminderType}%`}`,
       sql`${notifications.createdAt} >= ${startOfToday}`,
     ))
     .limit(1)
   ```
   If a matching reminder was already sent today for this user + reminderType, skip.

   Alternative approach for cleaner idempotency: encode the reminderType into the notification body or title in a predictable way (e.g., title includes "[upcoming]" or "[due_today]"). Then check for existence with a simpler query. Actually, simpler: use the title as the dedup key. Set title to a deterministic string like `Rent Reminder: ${reminderType} - ${currentPeriod}` and check if that exact title already exists for this user today.

6. Payment check -- before sending, check if tenant has already paid:
   ```typescript
   const paid = await db.select({ id: payments.id })
     .from(payments)
     .where(and(
       eq(payments.tenantUserId, link.userId),
       eq(payments.unitId, link.unitId),
       eq(payments.billingPeriod, currentPeriod),
       eq(payments.status, "succeeded"),
     ))
     .limit(1)
   ```
   If paid, skip the reminder.

7. Compose and send the notification via sendNotification:
   - type: "rent_reminder"
   - title: Deterministic title including reminderType and period (for idempotency)
   - body: Human-readable message like "Your rent of $X for Unit Y is due in Z days" / "Your rent is due today" / "Your rent is X days overdue"
   - channels: ["in_app", "email", "sms"] (sendNotification will check SMS opt-in internally)
   - emailHtml: Render the RentReminderEmail template (import from emails module)

8. Return JSON: `{ sent: number, skipped: number, errors: number }`.

9. Wrap the entire processing loop in try/catch per tenant to prevent one failure from stopping all reminders.

Important: Use `import { sql } from "drizzle-orm"` for the raw SQL fragments in the idempotency query.

Important: Format rent amount as dollars for display: `(rentAmountCents / 100).toFixed(2)` with leading $.
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>Cron API route at /api/cron/rent-reminders processes all active tenant-unit links, determines reminder type by due date proximity, checks idempotency and payment status, and sends notifications via all channels. Protected by CRON_SECRET bearer token.</done>
</task>

<task type="auto">
  <name>Task 2: Create rent reminder email template</name>
  <files>src/emails/RentReminderEmail.tsx</files>
  <action>
Create src/emails/RentReminderEmail.tsx using @react-email/components (already installed):

1. Check if a src/emails/ directory exists. If not, create it. If there are existing email templates in the project, follow their pattern. If not, create from scratch using @react-email/components.

2. The template accepts props:
   ```typescript
   interface RentReminderEmailProps {
     tenantName: string
     unitNumber: string
     rentAmount: string        // formatted like "$1,500.00"
     reminderType: "upcoming" | "due_today" | "overdue_1" | "overdue_3" | "overdue_7"
     dueDay: number
   }
   ```

3. Use @react-email/components: Html, Head, Body, Container, Section, Text, Hr, Preview.

4. Content varies by reminderType:
   - "upcoming": "Your rent of {rentAmount} for Unit {unitNumber} is due on the {dueDay}th of this month."
   - "due_today": "Your rent of {rentAmount} for Unit {unitNumber} is due today."
   - "overdue_1": "Your rent of {rentAmount} for Unit {unitNumber} was due yesterday. Please submit payment at your earliest convenience."
   - "overdue_3": "Your rent of {rentAmount} for Unit {unitNumber} is 3 days past due. Please submit payment as soon as possible."
   - "overdue_7": "Your rent of {rentAmount} for Unit {unitNumber} is 7 days past due. Immediate attention is required."

5. Simple, clean styling: white background, dark text, blue accent for the payment amount. Include a "Pay Now" link to `${process.env.NEXT_PUBLIC_APP_URL}/tenant/dashboard`.

6. Export the component as default and also export a `renderRentReminderEmail(props)` function that uses the `render` function from `@react-email/components` to return the HTML string.

7. Keep the design minimal and mobile-friendly. No complex layouts.
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>RentReminderEmail template renders styled HTML for all 5 reminder types. renderRentReminderEmail function exports ready-to-send HTML string.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- Cron route rejects requests without valid CRON_SECRET
- Cron route handles upcoming, due_today, and overdue reminder types
- Idempotency prevents duplicate reminders on same day
- Paid tenants are skipped
- Email template renders for all reminder types
</verification>

<success_criteria>
- POST /api/cron/rent-reminders with valid bearer token processes all active tenants
- Reminders are sent for 3-5 days before, day-of, and overdue (day 1, 3, 7)
- No duplicate reminders sent on cron re-runs
- Already-paid tenants receive no reminders
- Each reminder creates in-app + email + SMS notifications (SMS gated by opt-in)
- Styled email template renders correctly for all reminder types
</success_criteria>

<output>
After completion, create `.planning/phases/05-notifications-and-messaging/05-04-SUMMARY.md`
</output>
