---
phase: 05-notifications-and-messaging
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema/domain.ts
  - src/lib/twilio.ts
  - src/lib/notifications.ts
autonomous: true
requirements:
  - NOTIF-01
  - NOTIF-03
  - NOTIF-04
  - NOTIF-05

must_haves:
  truths:
    - "Notifications table exists in database with all required columns"
    - "Twilio client is available for SMS sending with lazy initialization"
    - "sendNotification helper dispatches to in-app, email, and SMS channels based on user preferences"
  artifacts:
    - path: "src/db/schema/domain.ts"
      provides: "notifications table schema"
      contains: "notifications"
    - path: "src/lib/twilio.ts"
      provides: "Twilio client singleton with lazy Proxy pattern"
      exports: ["getTwilioClient"]
    - path: "src/lib/notifications.ts"
      provides: "Unified notification dispatch function"
      exports: ["sendNotification"]
  key_links:
    - from: "src/lib/notifications.ts"
      to: "src/db/schema/domain.ts"
      via: "db.insert(notifications)"
      pattern: "db\\.insert\\(notifications\\)"
    - from: "src/lib/notifications.ts"
      to: "src/lib/resend.ts"
      via: "resend.emails.send for email channel"
      pattern: "resend\\.emails\\.send"
    - from: "src/lib/notifications.ts"
      to: "src/lib/twilio.ts"
      via: "getTwilioClient().messages.create for SMS channel"
      pattern: "messages\\.create"
---

<objective>
Create the notification infrastructure that all Phase 5 features depend on: the notifications database table, Twilio client for SMS, and a unified sendNotification dispatch helper.

Purpose: Every requirement in this phase (reminders, SMS, inbox, broadcast) depends on a shared notifications table and dispatch mechanism. Building this foundation first prevents duplication and ensures consistent behavior across all notification channels.

Output: notifications table in database, Twilio client module, sendNotification helper function.
</objective>

<execution_context>
@/Users/odesantos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/odesantos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-notifications-and-messaging/05-RESEARCH.md

@src/db/schema/domain.ts
@src/db/schema/index.ts
@src/lib/resend.ts
@src/db/index.ts

<interfaces>
<!-- Key types and contracts the executor needs. -->

From src/db/schema/auth.ts:
```typescript
export const user = pgTable("user", {
  id: text("id").primaryKey(),
  name: text("name").notNull(),
  email: text("email").notNull().unique(),
  phone: text("phone"),
  smsOptIn: boolean("sms_opt_in").default(false),
  smsOptInAt: text("sms_opt_in_at"),
  // ... other fields
})
```

From src/lib/resend.ts:
```typescript
export const resend = new Proxy({} as Resend, {
  get(_target, prop, receiver) {
    return Reflect.get(getResend(), prop, receiver)
  },
})
```

From src/db/index.ts (pattern to follow for lazy client):
```typescript
// Uses Proxy for lazy initialization -- Twilio client must follow same pattern
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add notifications table and Twilio client</name>
  <files>src/db/schema/domain.ts, src/lib/twilio.ts</files>
  <action>
1. Add the notifications table to src/db/schema/domain.ts at the bottom, after the Phase 4 tables. Add a Phase 5 section comment header matching the existing pattern (`// ==================== Phase 5: Notifications and Messaging ====================`).

The notifications table definition:
```typescript
export const notifications = pgTable("notifications", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: text("user_id").notNull(),           // Better Auth user.id (text)
  type: text("type", {
    enum: ["rent_reminder", "payment_confirmation", "broadcast", "maintenance_update", "system"],
  }).notNull(),
  title: text("title").notNull(),
  body: text("body").notNull(),
  channel: text("channel", {
    enum: ["in_app", "email", "sms"],
  }).default("in_app").notNull(),
  readAt: timestamp("read_at"),                // null = unread
  createdAt: timestamp("created_at").defaultNow().notNull(),
})
```

2. Create src/lib/twilio.ts following the exact lazy Proxy pattern from src/lib/resend.ts:
```typescript
import Twilio from "twilio"

let _client: ReturnType<typeof Twilio> | null = null

export function getTwilioClient() {
  if (!_client) {
    _client = Twilio(
      process.env.TWILIO_ACCOUNT_SID!,
      process.env.TWILIO_AUTH_TOKEN!
    )
  }
  return _client
}
```

Do NOT create a Proxy export for Twilio -- the Twilio SDK has a different interface than Resend. The direct `getTwilioClient()` function is sufficient and clearer.

3. Run `npx drizzle-kit push` to push the schema change to the database. This is the project's standard migration approach (push, not generate+migrate).
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && npx drizzle-kit push 2>&1 | tail -5 && node -e "const s = require('fs').readFileSync('src/db/schema/domain.ts','utf8'); if(!s.includes('notifications')) { process.exit(1) } else { console.log('notifications table found in schema') }"</automated>
  </verify>
  <done>notifications table exists in domain.ts schema and is pushed to database. Twilio client module exists at src/lib/twilio.ts with lazy initialization.</done>
</task>

<task type="auto">
  <name>Task 2: Create sendNotification dispatch helper</name>
  <files>src/lib/notifications.ts</files>
  <action>
Create src/lib/notifications.ts with a unified `sendNotification()` function that:

1. Accepts a payload with: userId, type (matching the enum), title, body, optional emailHtml, and channels array ("in_app" | "email" | "sms").

2. Always creates an in-app notification record in the notifications table (one record per channel dispatched, so the inbox shows each notification).

3. If channels includes "email": fetch user from DB, send via `resend.emails.send()` fire-and-forget (void). Use `from: "RentalMgmt <noreply@yourdomain.com>"` (use process.env.EMAIL_FROM or fallback). Subject = title, html = emailHtml ?? `<p>${body}</p>`.

4. If channels includes "sms": fetch user from DB, check `user.smsOptIn === true` AND `user.phone` is not null. If both true, send via `getTwilioClient().messages.create()` fire-and-forget (void). Use `messagingServiceSid: process.env.TWILIO_MESSAGING_SERVICE_SID` (NOT a `from` number). Body = plain text body.

5. Return the created notification record.

6. Export the TypeScript type for the notification payload as `NotificationPayload`.

7. Also export a `getNotificationsForUser(userId: string, options?: { unreadOnly?: boolean, limit?: number, offset?: number })` query helper that returns paginated notifications ordered by createdAt desc.

8. Also export a `markNotificationRead(notificationId: string, userId: string)` helper that sets readAt = now() where id matches AND userId matches (prevents marking other users' notifications as read).

9. Also export a `getUnreadCount(userId: string)` helper returning the count of notifications where readAt is null for that user.

Important: Email and SMS sends must be fire-and-forget (void) to never block the caller. Follow the existing pattern from the Stripe webhook where email is sent as `void resend.emails.send(...)`.

Important: Fetch user data only once even if both email and SMS channels are requested. Do not make two separate DB queries for the same user.
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && npx tsc --noEmit src/lib/notifications.ts 2>&1 | head -20</automated>
  </verify>
  <done>sendNotification function exists and type-checks. It creates in-app records and dispatches to email/SMS channels based on user preferences. getNotificationsForUser, markNotificationRead, and getUnreadCount helpers are exported.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no errors on new files
- notifications table exists in database (drizzle-kit push succeeded)
- src/lib/twilio.ts exports getTwilioClient
- src/lib/notifications.ts exports sendNotification, getNotificationsForUser, markNotificationRead, getUnreadCount
</verification>

<success_criteria>
- notifications schema is in domain.ts and pushed to DB
- Twilio client follows lazy initialization pattern
- sendNotification dispatches to in-app (always), email (if channel requested), SMS (if channel requested AND user opted in with phone)
- All helper functions type-check without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-notifications-and-messaging/05-01-SUMMARY.md`
</output>
