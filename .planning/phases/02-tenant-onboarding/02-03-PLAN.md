---
phase: 02-tenant-onboarding
plan: 03
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - src/app/invite/[token]/page.tsx
  - src/components/auth/InviteRegisterForm.tsx
autonomous: true
requirements:
  - AUTH-04

must_haves:
  truths:
    - "Scanning a valid QR code opens /invite/[token] and shows a registration form pre-associated with the unit"
    - "The invite page displays the unit number so the tenant knows which unit they are registering for"
    - "After submitting the registration form, the tenant is linked to the correct unit and redirected to /tenant/dashboard"
    - "An already-used invite token shows a clear 'This invite has already been used' error message"
    - "An expired invite token shows a clear 'This invite has expired' error message"
    - "An invalid/unknown token shows a clear 'Invalid invite link' error message"
  artifacts:
    - path: "src/app/invite/[token]/page.tsx"
      provides: "Server Component — validates token server-side, renders registration form or error state"
    - path: "src/components/auth/InviteRegisterForm.tsx"
      provides: "Client Component — registration form that passes inviteToken in the signup request body"
  key_links:
    - from: "src/app/invite/[token]/page.tsx"
      to: "src/lib/tokens.ts"
      via: "hashToken(token) to look up invite in database"
      pattern: "hashToken"
    - from: "src/app/invite/[token]/page.tsx"
      to: "src/db"
      via: "db.select from inviteTokens + units to validate token and get unit info"
      pattern: "inviteTokens"
    - from: "src/components/auth/InviteRegisterForm.tsx"
      to: "src/lib/auth-client.ts"
      via: "authClient.signUp.email({ email, password, name, inviteToken, callbackURL })"
      pattern: "signUp\\.email"
    - from: "src/components/auth/InviteRegisterForm.tsx"
      to: "src/lib/auth.ts (hook)"
      via: "inviteToken passed in signup body is read by the after-signup hook for consumption"
      pattern: "inviteToken"
---

<objective>
Build the tenant-facing invite flow: the /invite/[token] landing page that validates the token server-side and renders an invite-aware registration form, plus the InviteRegisterForm client component that passes the invite token through the signup request for the after-hook to consume.

Purpose: AUTH-04 success criteria #2-5 require the tenant to scan a QR code, see a registration form (or appropriate error), complete registration, and be automatically linked to their unit. The invite must be single-use and expire after 30 days.

Output: /invite/[token] server component page with error states, InviteRegisterForm client component that bridges the invite token to the Better Auth signup flow.
</objective>

<execution_context>
@/Users/odesantos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/odesantos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/02-tenant-onboarding/02-RESEARCH.md
@.planning/phases/02-tenant-onboarding/02-01-SUMMARY.md

<interfaces>
<!-- Key exports from Plan 01 that this plan uses -->

From src/lib/tokens.ts:
```typescript
export function hashToken(token: string): string  // SHA-256 hex digest for DB lookup
```

From src/db/schema/domain.ts:
```typescript
export const units = pgTable("units", {
  id: uuid("id").primaryKey().defaultRandom(),
  propertyId: uuid("property_id").references(() => properties.id).notNull(),
  unitNumber: text("unit_number").notNull(),
  ...
})

export const inviteTokens = pgTable("invite_tokens", {
  id: uuid("id").primaryKey().defaultRandom(),
  unitId: uuid("unit_id").references(() => units.id).notNull(),
  tokenHash: text("token_hash").notNull().unique(),
  status: text("status", { enum: ["pending", "used", "expired"] }).default("pending").notNull(),
  usedByUserId: text("used_by_user_id"),
  expiresAt: timestamp("expires_at").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  usedAt: timestamp("used_at"),
})
```

From src/lib/auth-client.ts:
```typescript
export const authClient: BetterAuthClient

// Sign up with email/password (Better Auth accepts additional fields in body — the after-hook reads them)
await authClient.signUp.email({
  email: string,
  password: string,
  name: string,
  callbackURL: string,
  // Additional fields passed through to the request body:
  inviteToken: string,  // Read by the after-signup hook in auth.ts
})
```

From src/lib/auth.ts (after-signup hook from Plan 01):
```typescript
// The hook reads ctx.body.inviteToken, hashes it, atomically consumes the invite,
// and creates a tenantUnits row linking the new user to the unit.
// If inviteToken is not present in the body, the hook is a no-op (normal registration).
```

Middleware note (from existing middleware.ts):
```typescript
// /invite/[token] is NOT under /tenant or /admin, so the existing middleware
// will NOT redirect unauthenticated users. No middleware changes needed.
// Current protected routes: pathname.startsWith("/tenant") || pathname.startsWith("/admin")
```

Existing auth form patterns (follow these conventions):
- "use client" directive
- react-hook-form + zodResolver for validation
- sonner toast for errors
- authClient.signUp.email / authClient.signIn.email
- shadcn/ui Button, Input, Label, Card
- Suspense boundary for components using useSearchParams()
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create /invite/[token] landing page with server-side token validation</name>
  <files>
    src/app/invite/[token]/page.tsx
  </files>
  <action>
Create src/app/invite/[token]/page.tsx as a Server Component that validates the invite token against the database and renders one of four states:

1. **Valid token**: Show unit info + InviteRegisterForm with token passed as prop
2. **Used token**: Show "This invite has already been used" error
3. **Expired token**: Show "This invite has expired" error
4. **Invalid token**: Show "Invalid invite link" error

```typescript
import { db } from "@/db"
import { inviteTokens, units } from "@/db/schema"
import { hashToken } from "@/lib/tokens"
import { eq } from "drizzle-orm"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { InviteRegisterForm } from "@/components/auth/InviteRegisterForm"
import Link from "next/link"

export default async function InvitePage({
  params,
}: {
  params: Promise<{ token: string }>
}) {
  const { token } = await params
  const tokenHash = hashToken(token)

  // Look up invite by hash
  const [invite] = await db
    .select({
      id: inviteTokens.id,
      unitId: inviteTokens.unitId,
      status: inviteTokens.status,
      expiresAt: inviteTokens.expiresAt,
    })
    .from(inviteTokens)
    .where(eq(inviteTokens.tokenHash, tokenHash))
    .limit(1)

  // State 4: Invalid token (not found)
  if (!invite) {
    return (
      <InviteLayout>
        <Card className="w-full max-w-sm">
          <CardHeader>
            <CardTitle>Invalid invite link</CardTitle>
            <CardDescription>
              This invite link is not recognized. Please contact your property manager for a new one.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <Link href="/auth/login" className="text-sm text-blue-600 hover:underline">
              Already have an account? Sign in
            </Link>
          </CardContent>
        </Card>
      </InviteLayout>
    )
  }

  // State 2: Used token
  if (invite.status === "used") {
    return (
      <InviteLayout>
        <Card className="w-full max-w-sm">
          <CardHeader>
            <CardTitle>Invite already used</CardTitle>
            <CardDescription>
              This invite has already been used to create an account. Each invite can only be used once.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <Link href="/auth/login" className="text-sm text-blue-600 hover:underline">
              Sign in to your account
            </Link>
          </CardContent>
        </Card>
      </InviteLayout>
    )
  }

  // State 3: Expired token
  const now = new Date()
  if (invite.expiresAt < now) {
    return (
      <InviteLayout>
        <Card className="w-full max-w-sm">
          <CardHeader>
            <CardTitle>Invite expired</CardTitle>
            <CardDescription>
              This invite link has expired. Please contact your property manager for a new one.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <Link href="/auth/login" className="text-sm text-blue-600 hover:underline">
              Already have an account? Sign in
            </Link>
          </CardContent>
        </Card>
      </InviteLayout>
    )
  }

  // Fetch unit info for display
  const [unit] = await db
    .select({ unitNumber: units.unitNumber })
    .from(units)
    .where(eq(units.id, invite.unitId))
    .limit(1)

  // State 1: Valid token — show registration form
  return (
    <InviteLayout>
      <Card className="w-full max-w-sm">
        <CardHeader>
          <CardTitle>Create your account</CardTitle>
          <CardDescription>
            You are registering for Unit {unit?.unitNumber ?? "Unknown"}.
            Create your account to access the tenant portal.
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <InviteRegisterForm
            inviteToken={token}
            unitNumber={unit?.unitNumber ?? "Unknown"}
          />
          <div className="text-center text-sm text-gray-600">
            Already have an account?{" "}
            <Link href="/auth/login" className="text-blue-600 hover:underline">
              Sign in
            </Link>
          </div>
        </CardContent>
      </Card>
    </InviteLayout>
  )
}

function InviteLayout({ children }: { children: React.ReactNode }) {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 px-4">
      {children}
    </div>
  )
}
```

IMPORTANT notes:
- `params` is a Promise in Next.js 15 — MUST await it.
- The page is at /invite/[token] which is NOT under /tenant or /admin, so the existing middleware allows unauthenticated access without any changes.
- The raw token is passed to InviteRegisterForm as a prop — it gets included in the signup request body for the after-hook to consume.
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>
    /invite/[token] page validates token server-side. Four states rendered: valid (registration form + unit number), used ("already used" message), expired ("invite expired" message), invalid ("not recognized" message). Raw token passed to InviteRegisterForm as prop. No middleware changes needed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create InviteRegisterForm that passes invite token through signup</name>
  <files>
    src/components/auth/InviteRegisterForm.tsx
  </files>
  <action>
Create src/components/auth/InviteRegisterForm.tsx — a Client Component similar to the existing RegisterForm but with the invite token passed through the signup body.

The key difference from the standard RegisterForm:
1. Accepts `inviteToken` and `unitNumber` as props
2. Passes `inviteToken` as an extra field in `authClient.signUp.email()` — Better Auth forwards additional body fields, and the after-signup hook reads `ctx.body.inviteToken`
3. Shows the unit number in context text

```typescript
"use client"

import { useState } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import { z } from "zod"
import { useRouter } from "next/navigation"
import { toast } from "sonner"
import { authClient } from "@/lib/auth-client"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"

const inviteRegisterSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  email: z.string().email("Enter a valid email"),
  password: z.string().min(8, "Password must be at least 8 characters"),
  confirmPassword: z.string(),
}).refine((data) => data.password === data.confirmPassword, {
  message: "Passwords do not match",
  path: ["confirmPassword"],
})

type InviteRegisterValues = z.infer<typeof inviteRegisterSchema>

interface InviteRegisterFormProps {
  inviteToken: string
  unitNumber: string
}

export function InviteRegisterForm({ inviteToken, unitNumber }: InviteRegisterFormProps) {
  const router = useRouter()
  const [isLoading, setIsLoading] = useState(false)

  const form = useForm<InviteRegisterValues>({
    resolver: zodResolver(inviteRegisterSchema),
    defaultValues: { name: "", email: "", password: "", confirmPassword: "" },
  })

  async function onSubmit(values: InviteRegisterValues) {
    setIsLoading(true)
    const { error } = await authClient.signUp.email({
      email: values.email,
      password: values.password,
      name: values.name,
      callbackURL: "/tenant/dashboard",
      // Extra field — Better Auth forwards this in the request body
      // The after-signup hook in auth.ts reads ctx.body.inviteToken
      inviteToken: inviteToken,
    } as Parameters<typeof authClient.signUp.email>[0] & { inviteToken: string })
    setIsLoading(false)

    if (error) {
      toast.error(error.message ?? "Registration failed. Try a different email.")
      return
    }

    toast.success(`Account created! You are now linked to Unit ${unitNumber}.`)
    router.push("/tenant/dashboard")
    router.refresh()
  }

  return (
    <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
      <div className="space-y-2">
        <Label htmlFor="name">Full name</Label>
        <Input id="name" placeholder="Jane Smith" {...form.register("name")} />
        {form.formState.errors.name && (
          <p className="text-sm text-red-600">{form.formState.errors.name.message}</p>
        )}
      </div>

      <div className="space-y-2">
        <Label htmlFor="email">Email</Label>
        <Input id="email" type="email" placeholder="you@example.com" {...form.register("email")} />
        {form.formState.errors.email && (
          <p className="text-sm text-red-600">{form.formState.errors.email.message}</p>
        )}
      </div>

      <div className="space-y-2">
        <Label htmlFor="password">Password</Label>
        <Input id="password" type="password" placeholder="********" {...form.register("password")} />
        {form.formState.errors.password && (
          <p className="text-sm text-red-600">{form.formState.errors.password.message}</p>
        )}
      </div>

      <div className="space-y-2">
        <Label htmlFor="confirmPassword">Confirm password</Label>
        <Input id="confirmPassword" type="password" placeholder="********" {...form.register("confirmPassword")} />
        {form.formState.errors.confirmPassword && (
          <p className="text-sm text-red-600">{form.formState.errors.confirmPassword.message}</p>
        )}
      </div>

      <Button type="submit" className="w-full" disabled={isLoading}>
        {isLoading ? "Creating account..." : "Create account"}
      </Button>
    </form>
  )
}
```

CRITICAL implementation notes:
- The `inviteToken` is passed as an extra field in `signUp.email()`. Better Auth will include it in the POST body to `/api/auth/sign-up/email`. The after-signup hook reads `ctx.body.inviteToken` to consume the token.
- The type assertion `as Parameters<typeof authClient.signUp.email>[0] & { inviteToken: string }` is needed because Better Auth's TypeScript types don't know about our custom field. The runtime handles it fine — Better Auth forwards all body fields.
- If the `inviteToken` field is NOT forwarded by Better Auth (verify during testing), the fallback approach is: set a cookie on the invite page server component using `cookies().set("invite_token", token)` and read it in the after-hook via `ctx.headers.get("cookie")`. But the body approach should work per Better Auth's hook documentation.
- Follow the exact same form patterns as the existing RegisterForm: react-hook-form, zodResolver, sonner toast, shadcn/ui components.
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && npx tsc --noEmit 2>&1 | head -20 && npm run build 2>&1 | tail -10</automated>
  </verify>
  <done>
    InviteRegisterForm.tsx exists with "use client" directive. Accepts inviteToken and unitNumber props. Passes inviteToken through signUp.email body for after-hook consumption. Uses same form validation pattern as RegisterForm (react-hook-form + zod). Shows success toast with unit number on completion. Build passes.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npx tsc --noEmit` — no TypeScript errors
2. `npm run build` — Next.js build passes
3. `ls src/app/invite/*/page.tsx` — invite page exists
4. `ls src/components/auth/InviteRegisterForm.tsx` — form component exists
5. `grep "hashToken" src/app/invite/*/page.tsx` — server-side token validation
6. `grep "inviteToken" src/components/auth/InviteRegisterForm.tsx` — token passed through signup
7. `grep "status.*used" src/app/invite/*/page.tsx` — used token error state
8. `grep "expiresAt" src/app/invite/*/page.tsx` — expiry check
</verification>

<success_criteria>
- /invite/[token] validates token server-side: invalid → "not recognized", used → "already used", expired → "expired", valid → registration form with unit context
- InviteRegisterForm passes inviteToken in signUp.email body for after-hook to read
- Unit number displayed on the invite page so tenant knows which unit they are registering for
- No middleware changes needed (path not under /tenant or /admin)
- Build passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-tenant-onboarding/02-03-SUMMARY.md`
</output>
