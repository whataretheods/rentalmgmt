---
phase: 02-tenant-onboarding
plan: 02
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - src/app/api/invites/generate/route.ts
  - src/app/api/invites/qr/[token]/route.ts
  - src/app/(admin)/admin/invites/page.tsx
  - src/components/admin/InviteManager.tsx
autonomous: true
requirements:
  - AUTH-04

must_haves:
  truths:
    - "Admin can see a list of all units with their invite status on the admin invites page"
    - "Admin can click a button to generate a new invite token for any unit"
    - "After generating, admin sees a QR code image and a copy-able invite link"
    - "Admin can download the QR code as a PNG image"
    - "The API stores only the hashed token in the database, returning the raw token only once"
  artifacts:
    - path: "src/app/api/invites/generate/route.ts"
      provides: "POST endpoint — generates invite token, stores hashed in DB, returns raw token + QR data URL"
      exports: ["POST"]
    - path: "src/app/api/invites/qr/[token]/route.ts"
      provides: "GET endpoint — returns QR code PNG for a given raw token (used for download)"
      exports: ["GET"]
    - path: "src/app/(admin)/admin/invites/page.tsx"
      provides: "Admin invites page — server component listing units with invite status"
    - path: "src/components/admin/InviteManager.tsx"
      provides: "Client component — generate invite, display QR code, copy link, download QR"
  key_links:
    - from: "src/app/api/invites/generate/route.ts"
      to: "src/lib/tokens.ts"
      via: "generateInviteToken(), hashToken(), getInviteExpiry()"
      pattern: "generateInviteToken|hashToken|getInviteExpiry"
    - from: "src/app/api/invites/generate/route.ts"
      to: "src/lib/qr.ts"
      via: "generateQRCodeDataURL() for inline preview"
      pattern: "generateQRCodeDataURL"
    - from: "src/app/api/invites/qr/[token]/route.ts"
      to: "src/lib/qr.ts"
      via: "generateQRCodeBuffer() for PNG download"
      pattern: "generateQRCodeBuffer"
    - from: "src/components/admin/InviteManager.tsx"
      to: "src/app/api/invites/generate/route.ts"
      via: "fetch('/api/invites/generate', { method: 'POST', body: { unitId } })"
      pattern: "fetch.*api/invites/generate"
    - from: "src/app/(admin)/admin/invites/page.tsx"
      to: "src/db"
      via: "db.select() from units + inviteTokens to build unit list with invite status"
      pattern: "db\\.select"
---

<objective>
Build the admin invite management interface: API routes for generating invite tokens and serving QR codes, and the admin UI page where admins can generate, view, and download QR code invites for each unit.

Purpose: AUTH-04 success criteria #1 requires the admin to generate per-unit invite tokens and download/print QR codes. This plan delivers that admin-facing capability. It depends on Plan 01's schema, token utilities, and QR utilities.

Output: POST /api/invites/generate endpoint, GET /api/invites/qr/[token] endpoint, admin invites page at /admin/invites, and InviteManager client component.
</objective>

<execution_context>
@/Users/odesantos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/odesantos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/02-tenant-onboarding/02-RESEARCH.md
@.planning/phases/02-tenant-onboarding/02-01-SUMMARY.md

<interfaces>
<!-- Key exports from Plan 01 that this plan uses -->

From src/lib/tokens.ts:
```typescript
export function generateInviteToken(): string     // 256-bit base64url token
export function hashToken(token: string): string   // SHA-256 hex digest
export function getInviteExpiry(): Date            // 30 days from now
```

From src/lib/qr.ts:
```typescript
export async function generateQRCodeBuffer(url: string): Promise<Buffer>  // PNG buffer
export async function generateQRCodeDataURL(url: string): Promise<string> // data:image/png;base64,...
```

From src/db/schema/domain.ts:
```typescript
export const properties = pgTable("properties", { id, name, address, ... })
export const units = pgTable("units", { id, propertyId, unitNumber, ... })
export const tenantUnits = pgTable("tenant_units", { id, userId, unitId, ... })
export const inviteTokens = pgTable("invite_tokens", {
  id: uuid("id").primaryKey().defaultRandom(),
  unitId: uuid("unit_id").references(() => units.id).notNull(),
  tokenHash: text("token_hash").notNull().unique(),
  status: text("status", { enum: ["pending", "used", "expired"] }).default("pending").notNull(),
  usedByUserId: text("used_by_user_id"),
  expiresAt: timestamp("expires_at").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  usedAt: timestamp("used_at"),
})
```

From src/db/index.ts:
```typescript
export const db  // NeonHttpDatabase<typeof schema>
```

From src/lib/auth.ts (for admin check):
```typescript
export const auth: BetterAuth
// auth.api.getSession({ headers: await headers() }) → session | null
// session.user.role === "admin" for admin check
```

Existing admin patterns from Phase 1 (follow these conventions):
- Admin pages at src/app/(admin)/admin/{name}/page.tsx — server component with db.select()
- Layout at src/app/(admin)/layout.tsx already enforces session + role === "admin"
- Client components at src/components/admin/{Name}.tsx
- shadcn/ui components available: Button, Input, Label, Card
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create API routes for invite generation and QR code serving</name>
  <files>
    src/app/api/invites/generate/route.ts
    src/app/api/invites/qr/[token]/route.ts
  </files>
  <action>
**Step 1: Create src/app/api/invites/generate/route.ts**

This endpoint is admin-only. It generates a new invite token for a unit, stores the hash, and returns the raw token + QR data URL.

```typescript
import { NextRequest, NextResponse } from "next/server"
import { auth } from "@/lib/auth"
import { headers } from "next/headers"
import { db } from "@/db"
import { inviteTokens, units } from "@/db/schema"
import { generateInviteToken, hashToken, getInviteExpiry } from "@/lib/tokens"
import { generateQRCodeDataURL } from "@/lib/qr"
import { eq } from "drizzle-orm"

export async function POST(request: NextRequest) {
  // Verify admin session
  const session = await auth.api.getSession({ headers: await headers() })
  if (!session || session.user.role !== "admin") {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
  }

  // Parse request body
  let body: { unitId?: string }
  try {
    body = await request.json()
  } catch {
    return NextResponse.json({ error: "Invalid request body" }, { status: 400 })
  }

  const { unitId } = body
  if (!unitId) {
    return NextResponse.json({ error: "unitId is required" }, { status: 400 })
  }

  // Verify unit exists
  const [unit] = await db
    .select({ id: units.id, unitNumber: units.unitNumber })
    .from(units)
    .where(eq(units.id, unitId))
    .limit(1)

  if (!unit) {
    return NextResponse.json({ error: "Unit not found" }, { status: 404 })
  }

  // Generate token and store hash
  const rawToken = generateInviteToken()
  const tokenHash = hashToken(rawToken)
  const expiresAt = getInviteExpiry()

  await db.insert(inviteTokens).values({
    unitId,
    tokenHash,
    expiresAt,
  })

  // Generate invite URL and QR code
  const appUrl = process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000"
  const inviteUrl = `${appUrl}/invite/${rawToken}`
  const qrDataUrl = await generateQRCodeDataURL(inviteUrl)

  return NextResponse.json({
    token: rawToken,
    inviteUrl,
    qrDataUrl,
    expiresAt: expiresAt.toISOString(),
    unitNumber: unit.unitNumber,
  })
}
```

**Step 2: Create src/app/api/invites/qr/[token]/route.ts**

This endpoint serves a downloadable QR code PNG for a given raw token. No auth required (the token itself is the secret, and this is used for download links the admin already has).

```typescript
import { NextRequest } from "next/server"
import { generateQRCodeBuffer } from "@/lib/qr"

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ token: string }> }
) {
  const { token } = await params
  const appUrl = process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000"
  const inviteUrl = `${appUrl}/invite/${token}`

  const buffer = await generateQRCodeBuffer(inviteUrl)

  return new Response(buffer, {
    headers: {
      "Content-Type": "image/png",
      "Content-Disposition": `attachment; filename="invite-${token.slice(0, 8)}.png"`,
      "Cache-Control": "no-store",
    },
  })
}
```

IMPORTANT: `params` is a Promise in Next.js 15 — must await it.

**Step 3: Add NEXT_PUBLIC_APP_URL to .env.example if it doesn't already exist**

Check .env.example and add if missing:
```
NEXT_PUBLIC_APP_URL=http://localhost:3000
```

This is the base URL used to construct invite links. In production, set to the actual domain.
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>
    POST /api/invites/generate: validates admin session, validates unitId, generates token, stores hash in DB, returns raw token + QR data URL + invite URL. GET /api/invites/qr/[token]: generates QR PNG buffer for download. NEXT_PUBLIC_APP_URL documented in .env.example. TypeScript compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create admin invites page and InviteManager component</name>
  <files>
    src/app/(admin)/admin/invites/page.tsx
    src/components/admin/InviteManager.tsx
  </files>
  <action>
**Step 1: Create src/app/(admin)/admin/invites/page.tsx**

Server component that fetches all units with their latest invite status and renders the InviteManager client component.

```typescript
import { db } from "@/db"
import { units, properties, inviteTokens } from "@/db/schema"
import { eq, desc } from "drizzle-orm"
import { InviteManager } from "@/components/admin/InviteManager"

export default async function AdminInvitesPage() {
  // Fetch all units with their property name
  const allUnits = await db
    .select({
      id: units.id,
      unitNumber: units.unitNumber,
      propertyName: properties.name,
      propertyId: units.propertyId,
    })
    .from(units)
    .innerJoin(properties, eq(units.propertyId, properties.id))
    .orderBy(units.unitNumber)

  // Fetch latest invite for each unit (pending only)
  const pendingInvites = await db
    .select({
      unitId: inviteTokens.unitId,
      status: inviteTokens.status,
      expiresAt: inviteTokens.expiresAt,
      createdAt: inviteTokens.createdAt,
    })
    .from(inviteTokens)
    .where(eq(inviteTokens.status, "pending"))
    .orderBy(desc(inviteTokens.createdAt))

  // Build unit data with invite status
  const unitsWithStatus = allUnits.map((unit) => {
    const invite = pendingInvites.find((inv) => inv.unitId === unit.id)
    return {
      id: unit.id,
      unitNumber: unit.unitNumber,
      propertyName: unit.propertyName,
      hasPendingInvite: !!invite,
      inviteExpiresAt: invite?.expiresAt?.toISOString() ?? null,
    }
  })

  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-2xl font-bold text-gray-900">Invite Tenants</h1>
        <p className="mt-1 text-sm text-gray-600">
          Generate QR code invites for each unit. Tenants scan the code to create their account and get linked automatically.
        </p>
      </div>
      <InviteManager units={unitsWithStatus} />
    </div>
  )
}
```

**Step 2: Create src/components/admin/InviteManager.tsx**

Client component with a table of units, "Generate Invite" buttons, and a dialog/section showing the generated QR code + invite link.

```typescript
"use client"

import { useState } from "react"
import { Button } from "@/components/ui/button"
import { toast } from "sonner"

interface UnitWithStatus {
  id: string
  unitNumber: string
  propertyName: string
  hasPendingInvite: boolean
  inviteExpiresAt: string | null
}

interface GeneratedInvite {
  token: string
  inviteUrl: string
  qrDataUrl: string
  expiresAt: string
  unitNumber: string
}

export function InviteManager({ units }: { units: UnitWithStatus[] }) {
  const [generating, setGenerating] = useState<string | null>(null)
  const [invite, setInvite] = useState<GeneratedInvite | null>(null)

  async function handleGenerate(unitId: string) {
    setGenerating(unitId)
    try {
      const res = await fetch("/api/invites/generate", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ unitId }),
      })

      if (!res.ok) {
        const data = await res.json()
        toast.error(data.error ?? "Failed to generate invite")
        return
      }

      const data: GeneratedInvite = await res.json()
      setInvite(data)
      toast.success(`Invite generated for Unit ${data.unitNumber}`)
    } catch {
      toast.error("Network error — could not generate invite")
    } finally {
      setGenerating(null)
    }
  }

  function handleCopyLink() {
    if (!invite) return
    navigator.clipboard.writeText(invite.inviteUrl)
    toast.success("Invite link copied to clipboard")
  }

  function handleDownloadQR() {
    if (!invite) return
    // Use the QR API endpoint for a clean PNG download
    const downloadUrl = `/api/invites/qr/${invite.token}`
    const a = document.createElement("a")
    a.href = downloadUrl
    a.download = `invite-${invite.token.slice(0, 8)}.png`
    document.body.appendChild(a)
    a.click()
    document.body.removeChild(a)
  }

  return (
    <div className="space-y-6">
      {/* Units table */}
      <div className="rounded-md border">
        <table className="w-full text-sm">
          <thead>
            <tr className="border-b bg-gray-50">
              <th className="px-4 py-3 text-left font-medium text-gray-700">Unit</th>
              <th className="px-4 py-3 text-left font-medium text-gray-700">Property</th>
              <th className="px-4 py-3 text-left font-medium text-gray-700">Invite Status</th>
              <th className="px-4 py-3 text-left font-medium text-gray-700">Action</th>
            </tr>
          </thead>
          <tbody>
            {units.length === 0 ? (
              <tr>
                <td colSpan={4} className="px-4 py-8 text-center text-gray-500">
                  No units found. Create units first via the seed script.
                </td>
              </tr>
            ) : (
              units.map((unit) => (
                <tr key={unit.id} className="border-b last:border-0">
                  <td className="px-4 py-3 font-medium text-gray-900">{unit.unitNumber}</td>
                  <td className="px-4 py-3 text-gray-600">{unit.propertyName}</td>
                  <td className="px-4 py-3">
                    {unit.hasPendingInvite ? (
                      <span className="inline-flex items-center rounded-full bg-yellow-100 px-2 py-0.5 text-xs font-medium text-yellow-800">
                        Pending (expires {new Date(unit.inviteExpiresAt!).toLocaleDateString()})
                      </span>
                    ) : (
                      <span className="inline-flex items-center rounded-full bg-gray-100 px-2 py-0.5 text-xs font-medium text-gray-600">
                        No invite
                      </span>
                    )}
                  </td>
                  <td className="px-4 py-3">
                    <Button
                      size="sm"
                      onClick={() => handleGenerate(unit.id)}
                      disabled={generating === unit.id}
                    >
                      {generating === unit.id ? "Generating..." : "Generate Invite"}
                    </Button>
                  </td>
                </tr>
              ))
            )}
          </tbody>
        </table>
      </div>

      {/* Generated invite display */}
      {invite && (
        <div className="rounded-lg border bg-white p-6 space-y-4">
          <h2 className="text-lg font-semibold text-gray-900">
            Invite for Unit {invite.unitNumber}
          </h2>
          <p className="text-sm text-gray-600">
            This QR code and link are valid until{" "}
            {new Date(invite.expiresAt).toLocaleDateString()}. Print or share with the tenant.
          </p>

          <div className="flex flex-col items-center gap-4 sm:flex-row sm:items-start">
            {/* QR Code preview */}
            <div className="shrink-0">
              <img
                src={invite.qrDataUrl}
                alt={`QR code for Unit ${invite.unitNumber}`}
                className="h-48 w-48 rounded border"
              />
            </div>

            {/* Link and actions */}
            <div className="flex-1 space-y-3">
              <div>
                <label className="text-xs font-medium text-gray-500">Invite Link</label>
                <div className="mt-1 flex items-center gap-2">
                  <input
                    type="text"
                    readOnly
                    value={invite.inviteUrl}
                    className="flex-1 rounded-md border bg-gray-50 px-3 py-2 text-sm text-gray-700 font-mono"
                    onClick={(e) => (e.target as HTMLInputElement).select()}
                  />
                  <Button size="sm" variant="outline" onClick={handleCopyLink}>
                    Copy
                  </Button>
                </div>
              </div>
              <Button size="sm" variant="outline" onClick={handleDownloadQR}>
                Download QR Code
              </Button>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}
```

This follows the existing admin UI patterns: server component page fetching data, client component for interactivity, shadcn/ui Button, table with same class patterns as UserTable.
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && npx tsc --noEmit 2>&1 | head -20 && npm run build 2>&1 | tail -10</automated>
  </verify>
  <done>
    Admin invites page at /admin/invites shows all units with invite status (pending/no invite). InviteManager lets admin generate invites — displays QR code inline, copy link button, download QR button. API generates token, stores hash, returns raw token + QR. Build passes.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npx tsc --noEmit` — no TypeScript errors
2. `npm run build` — Next.js build passes
3. `ls src/app/api/invites/generate/route.ts src/app/api/invites/qr/*/route.ts` — both API routes exist
4. `ls src/app/\(admin\)/admin/invites/page.tsx` — admin page exists
5. `ls src/components/admin/InviteManager.tsx` — client component exists
6. `grep "auth.api.getSession" src/app/api/invites/generate/route.ts` — admin auth check present
7. `grep "generateInviteToken" src/app/api/invites/generate/route.ts` — token generation
8. `grep "generateQRCodeBuffer" src/app/api/invites/qr/*/route.ts` — QR generation for download
</verification>

<success_criteria>
- POST /api/invites/generate: validates admin session, validates unitId exists, generates token, stores hash, returns raw token + QR data URL + invite URL + expiry
- GET /api/invites/qr/[token]: returns PNG buffer with Content-Disposition attachment header
- Admin invites page lists all units joined with property name, shows pending invite status with expiry date
- InviteManager component: generate button per unit, QR code preview, copy link, download QR
- All admin routes protected by existing admin layout (session + role check)
- Build passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-tenant-onboarding/02-02-SUMMARY.md`
</output>
