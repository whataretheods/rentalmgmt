---
phase: 02-tenant-onboarding
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema/domain.ts
  - src/lib/tokens.ts
  - src/lib/qr.ts
  - src/lib/auth.ts
  - package.json
autonomous: true
requirements:
  - AUTH-04

must_haves:
  truths:
    - "inviteTokens table exists in the database with columns: id, unitId, tokenHash, status, usedByUserId, expiresAt, createdAt, usedAt"
    - "generateInviteToken() returns a 256-bit URL-safe base64 string"
    - "hashToken(token) returns a SHA-256 hex digest"
    - "generateQRCodeBuffer(url) returns a PNG buffer"
    - "generateQRCodeDataURL(url) returns a data URL string"
    - "When a user signs up with an invite token, the after-signup hook consumes the token and creates a tenantUnits row"
  artifacts:
    - path: "src/db/schema/domain.ts"
      provides: "inviteTokens table definition with unitId FK, tokenHash, status enum, expiry"
      contains: "inviteTokens"
    - path: "src/lib/tokens.ts"
      provides: "Token generation (crypto.randomBytes) and hashing (SHA-256) utilities"
      exports: ["generateInviteToken", "hashToken"]
    - path: "src/lib/qr.ts"
      provides: "QR code generation as PNG buffer and data URL"
      exports: ["generateQRCodeBuffer", "generateQRCodeDataURL"]
    - path: "src/lib/auth.ts"
      provides: "After-signup hook that consumes invite tokens and links users to units"
      contains: "hooks"
  key_links:
    - from: "src/lib/auth.ts"
      to: "src/db/schema/domain.ts"
      via: "Imports inviteTokens and tenantUnits for token consumption and user-unit linking"
      pattern: "inviteTokens|tenantUnits"
    - from: "src/lib/auth.ts"
      to: "src/lib/tokens.ts"
      via: "Imports hashToken for verifying invite token during signup"
      pattern: "hashToken"
---

<objective>
Build the backend foundation for the invite token system: database schema, cryptographic token utilities, QR code generation, and the Better Auth after-signup hook that consumes tokens and links users to units.

Purpose: AUTH-04 requires a QR-code-based invite flow. Before any UI can be built, the data model, token utilities, and signup hook must exist. This plan creates all backend infrastructure that Plans 02 and 03 depend on.

Output: inviteTokens table in domain schema, token generation/hashing utilities, QR code generation utility, Better Auth after-signup hook, database migration applied.
</objective>

<execution_context>
@/Users/odesantos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/odesantos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/02-tenant-onboarding/02-RESEARCH.md

<interfaces>
<!-- Existing exports this plan uses and modifies -->

From src/db/schema/domain.ts (MODIFY — add inviteTokens table):
```typescript
// Existing tables — do NOT modify
export const properties = pgTable("properties", { ... })
export const units = pgTable("units", { ... })
export const tenantUnits = pgTable("tenant_units", { ... })
```

From src/db/schema/index.ts (no changes needed — already re-exports domain.ts):
```typescript
export * from "./auth"
export * from "./domain"
```

From src/db/index.ts:
```typescript
export const db  // Lazy Proxy to NeonHttpDatabase<typeof schema>
export type DB = NeonHttpDatabase<typeof schema>
```

From src/lib/auth.ts (MODIFY — add hooks):
```typescript
import { betterAuth } from "better-auth"
import { drizzleAdapter } from "better-auth/adapters/drizzle"
import { admin } from "better-auth/plugins"
import { nextCookies } from "better-auth/next-js"
import { db } from "@/db"
import * as schema from "@/db/schema"
import { resend } from "@/lib/resend"

export const auth = betterAuth({
  database: drizzleAdapter(db, { provider: "pg", schema }),
  emailAndPassword: { enabled: true, minPasswordLength: 8, ... },
  plugins: [admin({ defaultRole: "user", adminRoles: ["admin"] }), nextCookies()],
  user: { additionalFields: { smsOptIn: ..., smsOptInAt: ... } },
})
export type Session = typeof auth.$Infer.Session
export type User = typeof auth.$Infer.Session.user
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add inviteTokens schema, install qrcode, create token and QR utilities</name>
  <files>
    src/db/schema/domain.ts
    src/lib/tokens.ts
    src/lib/qr.ts
    package.json
  </files>
  <action>
**Step 1: Install qrcode package**

```bash
cd /Users/odesantos/Documents/rentalmgmt && npm install qrcode && npm install -D @types/qrcode
```

**Step 2: Add inviteTokens table to src/db/schema/domain.ts**

Add to the BOTTOM of the existing file (after the tenantUnits table). Do NOT modify existing tables.

```typescript
// Invite tokens — single-use, time-limited QR code invitations linking tenants to units
export const inviteTokens = pgTable("invite_tokens", {
  id: uuid("id").primaryKey().defaultRandom(),
  unitId: uuid("unit_id")
    .references(() => units.id, { onDelete: "cascade" })
    .notNull(),
  tokenHash: text("token_hash").notNull().unique(),  // SHA-256 hash of raw token
  status: text("status", { enum: ["pending", "used", "expired"] })
    .default("pending")
    .notNull(),
  usedByUserId: text("used_by_user_id"),  // populated when consumed (text matches Better Auth user.id type)
  expiresAt: timestamp("expires_at").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  usedAt: timestamp("used_at"),
})
```

**Step 3: Create src/lib/tokens.ts**

```typescript
import { randomBytes, createHash } from "crypto"

/** Generate a 256-bit cryptographically secure URL-safe token */
export function generateInviteToken(): string {
  return randomBytes(32).toString("base64url")
}

/** Hash a token with SHA-256 for database storage */
export function hashToken(token: string): string {
  return createHash("sha256").update(token).digest("hex")
}

/** Default invite token expiration: 30 days from now */
export function getInviteExpiry(): Date {
  const expiry = new Date()
  expiry.setDate(expiry.getDate() + 30)
  return expiry
}
```

**Step 4: Create src/lib/qr.ts**

```typescript
import QRCode from "qrcode"

/** Generate a QR code PNG buffer for an invite URL */
export async function generateQRCodeBuffer(url: string): Promise<Buffer> {
  return QRCode.toBuffer(url, {
    errorCorrectionLevel: "H",  // High — withstands print damage
    width: 400,
    margin: 2,
    color: { dark: "#000000", light: "#FFFFFF" },
  })
}

/** Generate a QR code as a data URL (for inline display) */
export async function generateQRCodeDataURL(url: string): Promise<string> {
  return QRCode.toDataURL(url, {
    errorCorrectionLevel: "H",
    width: 400,
    margin: 2,
  })
}
```
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>
    inviteTokens table added to domain.ts after existing tables. src/lib/tokens.ts exports generateInviteToken, hashToken, getInviteExpiry. src/lib/qr.ts exports generateQRCodeBuffer, generateQRCodeDataURL. qrcode and @types/qrcode installed. TypeScript compiles with no errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Better Auth after-signup hook and run database migration</name>
  <files>
    src/lib/auth.ts
  </files>
  <action>
**Step 1: Modify src/lib/auth.ts — add after-signup hook**

Add imports at the top:
```typescript
import { createAuthMiddleware } from "better-auth/api"
import { eq, and, gt } from "drizzle-orm"
import { inviteTokens, tenantUnits } from "@/db/schema"
import { hashToken } from "@/lib/tokens"
```

Add the `hooks` property to the betterAuth config object, AFTER the `user` property:

```typescript
hooks: {
  after: createAuthMiddleware(async (ctx) => {
    // Only process signup requests
    if (!ctx.path.startsWith("/sign-up")) return

    const newSession = ctx.context.newSession
    if (!newSession) return

    // Read invite token from request body (passed as extra field by invite registration form)
    let body: Record<string, unknown> = {}
    try {
      body = ctx.body as Record<string, unknown> ?? {}
    } catch {
      // Body may not be parseable — skip invite processing
      return
    }

    const inviteToken = body.inviteToken as string | undefined
    if (!inviteToken) return  // Normal registration (no invite) — skip

    const tokenHash = hashToken(inviteToken)
    const now = new Date()

    // Atomic consumption: UPDATE WHERE status='pending' AND not expired
    // If 0 rows returned, token was already used, expired, or invalid
    const [consumed] = await db
      .update(inviteTokens)
      .set({
        status: "used",
        usedByUserId: newSession.user.id,
        usedAt: now,
      })
      .where(
        and(
          eq(inviteTokens.tokenHash, tokenHash),
          eq(inviteTokens.status, "pending"),
          gt(inviteTokens.expiresAt, now),
        )
      )
      .returning()

    if (!consumed) {
      // Token invalid/expired/already used — user is created but not linked
      // They'll see an "unlinked" state on their dashboard
      console.warn("Invite token consumption failed for user:", newSession.user.id)
      return
    }

    // Link user to unit
    await db.insert(tenantUnits).values({
      userId: newSession.user.id,
      unitId: consumed.unitId,
      startDate: now,
      isActive: true,
    })

    console.log("Tenant linked to unit:", {
      userId: newSession.user.id,
      unitId: consumed.unitId,
    })
  }),
},
```

CRITICAL: The `db` import is already available via `import { db } from "@/db"` — add this import if not already present.

**Step 2: Generate and apply database migration**

```bash
cd /Users/odesantos/Documents/rentalmgmt && npm run db:generate && npm run db:migrate
```

If `db:migrate` fails (e.g., connection issue), try `npm run db:push` as fallback.

**Step 3: Verify the migration applied correctly**

```bash
cd /Users/odesantos/Documents/rentalmgmt && npm run db:push 2>&1 | tail -5
```
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && npx tsc --noEmit 2>&1 | head -20 && npm run build 2>&1 | tail -10</automated>
  </verify>
  <done>
    auth.ts has hooks.after with createAuthMiddleware that processes /sign-up paths, reads inviteToken from body, atomically consumes token with status+expiry check, and inserts tenantUnits row. Database migration for invite_tokens table has been generated and applied. TypeScript compiles and Next.js build passes.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npx tsc --noEmit` — no TypeScript errors
2. `npm run build` — Next.js build passes
3. `grep "inviteTokens" src/db/schema/domain.ts` — table exists
4. `grep "generateInviteToken" src/lib/tokens.ts` — utility exports
5. `grep "generateQRCodeBuffer" src/lib/qr.ts` — QR utility exports
6. `grep "createAuthMiddleware" src/lib/auth.ts` — hook is wired
7. `grep "inviteToken" src/lib/auth.ts` — reads invite token from signup body
8. `ls drizzle/*.sql | tail -1` — migration file exists for invite_tokens
</verification>

<success_criteria>
- inviteTokens table in domain.ts with uuid id, unitId FK, tokenHash unique, status enum, expiresAt, usedByUserId, usedAt
- Token utilities: generateInviteToken (256-bit base64url), hashToken (SHA-256 hex), getInviteExpiry (30 days)
- QR utilities: generateQRCodeBuffer (PNG), generateQRCodeDataURL (data URL)
- auth.ts hooks.after processes /sign-up, reads inviteToken from body, atomically consumes with status+expiry check, creates tenantUnits row
- Database migration generated and applied
- Build passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-tenant-onboarding/02-01-SUMMARY.md`
</output>
