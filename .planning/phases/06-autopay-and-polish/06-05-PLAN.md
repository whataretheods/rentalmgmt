---
phase: 06-autopay-and-polish
plan: 05
type: execute
wave: 3
depends_on: ["06-02"]
files_modified:
  - src/app/(tenant)/tenant/dashboard/page.tsx
  - src/app/(tenant)/tenant/payments/page.tsx
  - src/app/(tenant)/tenant/maintenance/page.tsx
  - src/app/(tenant)/tenant/documents/page.tsx
  - src/app/(tenant)/tenant/profile/page.tsx
  - src/app/(tenant)/tenant/notifications/page.tsx
  - src/app/(tenant)/tenant/autopay/page.tsx
  - src/app/(admin)/admin/dashboard/page.tsx
  - src/app/(admin)/admin/payments/page.tsx
  - src/app/(admin)/admin/maintenance/page.tsx
  - src/app/(admin)/admin/documents/page.tsx
  - src/app/(admin)/admin/notifications/page.tsx
  - src/app/(admin)/admin/broadcast/page.tsx
  - src/components/ui/skeleton.tsx
  - src/components/ui/error-boundary.tsx
  - src/components/ui/empty-state.tsx
autonomous: true
requirements:
  - PAY-06

must_haves:
  truths:
    - "All tenant-facing pages are mobile responsive at 375px viewport"
    - "Skeleton loaders shown during data loading across all pages"
    - "Empty states rendered when no data exists"
    - "Error boundaries catch and display component errors gracefully"
    - "Toast feedback used for all user actions (success, error)"
    - "Admin pages have loading states and error handling"
  artifacts:
    - path: "src/components/ui/skeleton.tsx"
      provides: "Skeleton loader component (may already exist from shadcn)"
    - path: "src/components/ui/empty-state.tsx"
      provides: "Reusable empty state component"
    - path: "src/components/ui/error-boundary.tsx"
      provides: "Client-side error boundary component"
  key_links:
    - from: "src/components/ui/empty-state.tsx"
      to: "lucide-react"
      via: "icons for empty state illustrations"
      pattern: "lucide-react"
---

<objective>
Polish all tenant-facing and admin pages with mobile responsiveness, skeleton loaders, empty states, error boundaries, and consistent toast feedback.

Purpose: This plan addresses the polish requirements from CONTEXT.md. Every page should feel complete — no broken layouts on mobile, no blank screens during loading, no cryptic errors. The focus is on the tenant experience first (they're the end users) with admin pages getting the same treatment.

Output: Reusable UI components (skeleton, empty-state, error-boundary), polished tenant pages, polished admin pages.
</objective>

<execution_context>
@/Users/odesantos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/odesantos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-autopay-and-polish/06-RESEARCH.md
@.planning/phases/06-autopay-and-polish/06-CONTEXT.md

@src/app/(tenant)/tenant/dashboard/page.tsx
@src/app/(tenant)/tenant/payments/page.tsx
@src/app/(tenant)/tenant/maintenance/page.tsx
@src/app/(tenant)/tenant/documents/page.tsx
@src/app/(tenant)/tenant/profile/page.tsx
@src/app/(admin)/admin/dashboard/page.tsx
@src/app/(admin)/admin/payments/page.tsx

<interfaces>
Existing UI pattern (from PaymentSummaryCard):
```typescript
// Cards use: rounded-lg border bg-white p-4
// Badges use: inline-flex items-center rounded-full px-2 py-0.5 text-xs font-medium
// Grid: grid grid-cols-1 sm:grid-cols-3 gap-4
```

Tailwind v4 with tw-animate-css:
```typescript
// Skeleton animation: animate-pulse bg-gray-200 rounded
```

Toast pattern (already used across app):
```typescript
import { toast } from "sonner"
toast.success("Action completed")
toast.error("Something went wrong")
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reusable polish UI components</name>
  <files>src/components/ui/skeleton.tsx, src/components/ui/empty-state.tsx, src/components/ui/error-boundary.tsx</files>
  <action>
1. Check if src/components/ui/skeleton.tsx already exists (shadcn may have installed it). If it does, verify it has the standard `<Skeleton className="..." />` component. If not, create it:

```typescript
import { cn } from "@/lib/utils"

function Skeleton({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-gray-200", className)}
      {...props}
    />
  )
}

export { Skeleton }
```

2. Create src/components/ui/empty-state.tsx — a reusable empty state component:

```typescript
import { LucideIcon } from "lucide-react"

interface EmptyStateProps {
  icon?: LucideIcon
  title: string
  description?: string
  action?: React.ReactNode  // optional CTA button
}

export function EmptyState({ icon: Icon, title, description, action }: EmptyStateProps) {
  return (
    <div className="flex flex-col items-center justify-center py-12 text-center">
      {Icon && <Icon className="h-12 w-12 text-gray-300 mb-4" />}
      <h3 className="text-lg font-medium text-gray-900">{title}</h3>
      {description && <p className="mt-1 text-sm text-gray-500 max-w-sm">{description}</p>}
      {action && <div className="mt-4">{action}</div>}
    </div>
  )
}
```

3. Create src/components/ui/error-boundary.tsx — a client-side error boundary:

```typescript
"use client"

import React from "react"
import { Button } from "@/components/ui/button"

interface ErrorBoundaryProps {
  children: React.ReactNode
  fallback?: React.ReactNode
}

interface ErrorBoundaryState {
  hasError: boolean
  error: Error | null
}

export class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props)
    this.state = { hasError: false, error: null }
  }

  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, info: React.ErrorInfo) {
    console.error("ErrorBoundary caught:", error, info)
  }

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) return this.props.fallback
      return (
        <div className="rounded-lg border border-red-200 bg-red-50 p-6 text-center">
          <h3 className="text-lg font-medium text-red-800">Something went wrong</h3>
          <p className="mt-1 text-sm text-red-600">
            {this.state.error?.message || "An unexpected error occurred"}
          </p>
          <Button
            variant="outline"
            size="sm"
            className="mt-4"
            onClick={() => this.setState({ hasError: false, error: null })}
          >
            Try Again
          </Button>
        </div>
      )
    }
    return this.props.children
  }
}
```
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>Skeleton, EmptyState, and ErrorBoundary components created and type-check. Ready for use across all pages.</done>
</task>

<task type="auto">
  <name>Task 2: Polish all tenant and admin pages</name>
  <files>src/app/(tenant)/tenant/payments/page.tsx, src/app/(tenant)/tenant/maintenance/page.tsx, src/app/(tenant)/tenant/documents/page.tsx, src/app/(tenant)/tenant/profile/page.tsx, src/app/(tenant)/tenant/notifications/page.tsx, src/app/(tenant)/tenant/autopay/page.tsx, src/app/(admin)/admin/dashboard/page.tsx, src/app/(admin)/admin/payments/page.tsx, src/app/(admin)/admin/maintenance/page.tsx, src/app/(admin)/admin/documents/page.tsx, src/app/(admin)/admin/notifications/page.tsx, src/app/(admin)/admin/broadcast/page.tsx</files>
  <action>
Apply consistent polish to ALL tenant-facing and admin pages. For each page:

**Mobile Responsiveness (375px):**
- Audit each page's layout classes. Replace any `grid-cols-*` that don't have `grid-cols-1` as mobile default
- Ensure all tables are wrapped in `overflow-x-auto` div for horizontal scroll on mobile
- Ensure buttons are full-width on mobile: `w-full sm:w-auto`
- Ensure padding scales: `p-4 sm:p-6`
- Ensure text doesn't overflow: `break-words` on long content
- Check that fixed-width elements have responsive alternatives

**Loading States:**
- For each page that fetches data, add a Next.js `loading.tsx` file in the same directory OR use Suspense boundaries with skeleton fallbacks
- Actually, since these are server components, the best approach is:
  - Create `loading.tsx` files that show skeleton layouts matching each page's structure
  - Keep it simple: use `<Skeleton>` with appropriate widths and heights matching the content layout

Create these loading files:
- `src/app/(tenant)/tenant/payments/loading.tsx` — skeleton table with 5 rows
- `src/app/(tenant)/tenant/maintenance/loading.tsx` — skeleton cards x3
- `src/app/(tenant)/tenant/documents/loading.tsx` — skeleton list
- `src/app/(tenant)/tenant/profile/loading.tsx` — skeleton form fields
- `src/app/(tenant)/tenant/notifications/loading.tsx` — skeleton notification list
- `src/app/(tenant)/tenant/autopay/loading.tsx` — skeleton card
- `src/app/(tenant)/tenant/dashboard/loading.tsx` — skeleton dashboard sections
- `src/app/(admin)/admin/dashboard/loading.tsx` — skeleton overview
- `src/app/(admin)/admin/payments/loading.tsx` — skeleton table
- `src/app/(admin)/admin/maintenance/loading.tsx` — skeleton kanban/list
- `src/app/(admin)/admin/documents/loading.tsx` — skeleton list
- `src/app/(admin)/admin/notifications/loading.tsx` — skeleton list
- `src/app/(admin)/admin/broadcast/loading.tsx` — skeleton form

Each loading.tsx pattern:
```typescript
import { Skeleton } from "@/components/ui/skeleton"

export default function Loading() {
  return (
    <div className="space-y-4">
      <Skeleton className="h-8 w-48" />  {/* Page title */}
      <div className="space-y-3">
        <Skeleton className="h-20 w-full" />  {/* Content area */}
        <Skeleton className="h-20 w-full" />
        <Skeleton className="h-20 w-full" />
      </div>
    </div>
  )
}
```

**Empty States:**
- Where pages currently show nothing when data is empty, add EmptyState components:
  - Payments page: "No payments yet" with CTA to pay rent
  - Maintenance page: "No maintenance requests" with CTA to submit one
  - Documents page: "No documents uploaded" with CTA to upload
  - Notifications page: "No notifications" — all caught up
  - Use appropriate Lucide icons: CreditCard, Wrench, FileText, Bell

**Error Handling:**
- Wrap client components that could fail (forms, API-calling components) with ErrorBoundary
- Ensure all fetch calls in client components have try/catch with toast.error feedback
- Check existing client components (PayRentButton, AutopayEnrollForm, etc.) and add error handling where missing

**Admin pages to polish (focus areas per Claude's discretion):**
- admin/payments: ensure table is responsive, add loading skeleton
- admin/maintenance: ensure kanban/list responsive, add loading
- admin/documents: responsive list, loading
- admin/dashboard: responsive cards, loading
- admin/broadcast: responsive form, loading
- admin/notifications: responsive list, loading

Important: Do NOT rewrite page logic or change functionality. Only add: responsive classes, loading.tsx files, empty states, error boundaries, and consistent toast feedback. This is a polish pass, not a refactor.

Important: Each loading.tsx should loosely match the visual structure of its page (skeleton shapes approximating the actual content layout).
  </action>
  <verify>
    <automated>cd /Users/odesantos/Documents/rentalmgmt && npx tsc --noEmit 2>&1 | head -30 && ls src/app/\(tenant\)/tenant/*/loading.tsx src/app/\(admin\)/admin/*/loading.tsx 2>/dev/null | wc -l</automated>
  </verify>
  <done>All tenant and admin pages have loading.tsx skeletons, empty states, responsive layouts, and error boundaries. Mobile-first responsive classes applied throughout. Toast feedback consistent across all interactive components.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- loading.tsx files exist for all major page directories (13+ files)
- EmptyState component used where data can be empty
- ErrorBoundary wraps client components that make API calls
- All grid layouts have mobile-first responsive classes
- Tables wrapped in overflow-x-auto
</verification>

<success_criteria>
- Every tenant page renders cleanly at 375px viewport width
- Every page has a loading skeleton that matches its content layout
- Empty data states show helpful messages with CTAs
- Client-side errors are caught by ErrorBoundary with recovery option
- All user actions (form submits, API calls) have toast success/error feedback
- Admin pages receive the same polish treatment
</success_criteria>

<output>
After completion, create `.planning/phases/06-autopay-and-polish/06-05-SUMMARY.md`
</output>
