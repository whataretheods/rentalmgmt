---
phase: 08-financial-ledger-foundation
plan: 03
type: execute
wave: 2
depends_on: [08-01]
files_modified:
  - src/app/(tenant)/tenant/dashboard/page.tsx
  - src/app/(admin)/admin/payments/page.tsx
  - src/app/api/admin/payments-overview/route.ts
  - src/components/tenant/BalanceCard.tsx
autonomous: true
requirements: [LEDG-02]

must_haves:
  truths:
    - Tenant dashboard displays a computed running balance showing "You owe $X" based on charges minus payments
    - When tenant has no balance, dashboard shows "All caught up" or "$0.00"
    - When tenant has a credit, dashboard shows the credit amount distinctly
    - Admin payment dashboard shows per-tenant balance alongside existing payment info
  artifacts:
    - src/components/tenant/BalanceCard.tsx (new balance display component)
    - src/app/(tenant)/tenant/dashboard/page.tsx (modified to show balance)
    - src/app/api/admin/payments-overview/route.ts (modified to include balance)
    - src/app/(admin)/admin/payments/page.tsx (modified to show balance column)
  key_links:
    - BalanceCard imports and uses getTenantBalance from src/lib/ledger.ts
    - Admin payments-overview API computes per-unit balance from charges and payments tables
    - Balance computation is consistent between tenant and admin views
---

<objective>
Display running balances on both tenant dashboard and admin payment views.

Purpose: Make the computed balance (charges - payments) visible to tenants ("You owe $X") and admins (per-tenant balance in payment dashboard). This is LEDG-02.
Output: BalanceCard component on tenant dashboard, balance column in admin payments view.
</objective>

<execution_context>
@/Users/odesantos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/odesantos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/08-financial-ledger-foundation/08-RESEARCH.md
@.planning/phases/08-financial-ledger-foundation/08-01-SUMMARY.md

<interfaces>
<!-- Balance computation helper from Plan 01 -->
From src/lib/ledger.ts:
```typescript
export async function getTenantBalance(tenantUserId: string, unitId: string): Promise<number>
export function formatBalance(balanceCents: number): { text: string; status: "owed" | "credit" | "current" }
```

<!-- Current tenant dashboard structure -->
From src/app/(tenant)/tenant/dashboard/page.tsx:
```typescript
// Server component — fetches session, tenant unit link, unit details, last payment
// Uses PaymentSummaryCard, AutopayStatusCard, PayRentButton, DashboardMaintenance, DashboardNotifications
// Key data: session.user.id, link.unitId, unit.rentAmountCents, lastPayment
```

<!-- Existing PaymentSummaryCard props -->
From src/components/tenant/PaymentSummaryCard.tsx (expected):
```typescript
// Props: rentAmountCents, rentDueDay, lastPayment (amountCents, status, paidAt, paymentMethod)
```

<!-- Admin payments overview API -->
From src/app/api/admin/payments-overview/route.ts:
```typescript
// Returns: { units: Array<{ unitId, unitNumber, propertyName, tenantName, tenantEmail, rentAmountCents, amountPaidCents, status, lastPaymentDate }>, period }
```

<!-- Admin payments page -->
From src/app/(admin)/admin/payments/page.tsx:
```typescript
// Server component that fetches from /api/admin/payments-overview and renders PaymentDashboard
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BalanceCard and integrate into tenant dashboard</name>
  <files>src/components/tenant/BalanceCard.tsx, src/app/(tenant)/tenant/dashboard/page.tsx</files>
  <action>
1. **Create src/components/tenant/BalanceCard.tsx** — a server-compatible component that displays the tenant's running balance.

```typescript
// This is a presentational component (not "use client") that receives balance data as props
// The parent server component (dashboard) will compute the balance and pass it

interface BalanceCardProps {
  balanceCents: number
  hasPendingPayments: boolean
}
```

**Display logic:**
- If balanceCents > 0: Show "You owe" with the amount in a prominent red/amber card. E.g., "You owe $1,500.00"
- If balanceCents === 0: Show "All caught up!" in a green card with a check icon
- If balanceCents < 0: Show "Credit: $50.00" in a blue card (tenant overpaid or has a credit)
- If hasPendingPayments is true and balance > 0: Show a small "Pending payment processing" note below the amount

**Styling:** Use a Card component (from shadcn/ui or a simple div with rounded border). Match the visual weight of the existing PaymentSummaryCard — it should be the first thing tenants see. Use Tailwind colors:
- Owed: `bg-red-50 border-red-200 text-red-800` (or amber for softer tone)
- Current: `bg-green-50 border-green-200 text-green-800`
- Credit: `bg-blue-50 border-blue-200 text-blue-800`

Format amount using `(cents / 100).toFixed(2)` with dollar sign prefix.

2. **Modify src/app/(tenant)/tenant/dashboard/page.tsx**:

Add balance computation to the server component data fetching:

```typescript
import { getTenantBalance } from "@/lib/ledger"
import { BalanceCard } from "@/components/tenant/BalanceCard"
```

After fetching the tenant's unit link, compute balance:
```typescript
const balanceCents = await getTenantBalance(session.user.id, link.unitId)

// Check for pending payments
const [pendingPayment] = await db
  .select({ id: payments.id })
  .from(payments)
  .where(
    and(
      eq(payments.tenantUserId, session.user.id),
      eq(payments.unitId, link.unitId),
      eq(payments.status, "pending")
    )
  )
  .limit(1)

const hasPendingPayments = !!pendingPayment
```

Place the `<BalanceCard balanceCents={balanceCents} hasPendingPayments={hasPendingPayments} />` at the TOP of the dashboard content, BEFORE the PaymentSummaryCard. This makes balance the most prominent element. The existing PaymentSummaryCard still shows last payment details — the BalanceCard shows the overall financial picture.

Import `charges` from `@/db/schema` if needed for any direct queries (though getTenantBalance handles this internally).
  </action>
  <verify>
    <automated>npx next build 2>&1 | tail -10</automated>
    Build succeeds. Navigate to /tenant/dashboard — BalanceCard renders at top with balance amount.
  </verify>
  <done>
    - BalanceCard component renders balance with appropriate color coding (owed/current/credit)
    - Tenant dashboard shows BalanceCard as the first visual element
    - Balance is computed server-side using getTenantBalance
    - Pending payment indicator shows when applicable
    - Existing dashboard elements (PaymentSummaryCard, AutopayStatusCard, etc.) remain intact
  </done>
</task>

<task type="auto">
  <name>Task 2: Add per-tenant balance to admin payment dashboard</name>
  <files>src/app/api/admin/payments-overview/route.ts, src/app/(admin)/admin/payments/page.tsx</files>
  <action>
1. **Modify src/app/api/admin/payments-overview/route.ts** — add balance computation to the response.

After the existing query logic (which computes period payments), add a balance query that computes per-unit balances from the charges and payments tables:

```typescript
import { charges } from "@/db/schema"

// After existing queries, compute per-unit balance from charges table
const unitBalances = await db
  .execute(sql`
    SELECT
      c.unit_id,
      COALESCE(SUM(c.amount_cents), 0)
      -
      COALESCE((
        SELECT SUM(p.amount_cents)
        FROM payments p
        WHERE p.unit_id = c.unit_id
        AND p.tenant_user_id = c.tenant_user_id
        AND p.status = 'succeeded'
      ), 0) AS balance_cents
    FROM charges c
    GROUP BY c.unit_id, c.tenant_user_id
  `)
```

Alternative simpler approach — compute balance inline for each unit in the result mapping:

In the result mapping section, for each unit that has an active tenant, compute:
```typescript
// Get total charges for this tenant/unit
const unitCharges = await db
  .select({
    totalCharges: sql<number>`COALESCE(SUM(amount_cents), 0)`.as("total_charges")
  })
  .from(charges)
  .where(and(
    eq(charges.tenantUserId, tenantUserId),
    eq(charges.unitId, unit.unitId)
  ))
```

But this would be N+1 queries. Better: do a single aggregated query for all tenant-unit pairs and build a map, similar to the existing `periodPayments` pattern:

```typescript
// 3b. Get charge totals per tenant-unit pair
const chargeTotals = await db
  .select({
    tenantUserId: charges.tenantUserId,
    unitId: charges.unitId,
    totalChargesCents: sql<number>`COALESCE(SUM(${charges.amountCents}), 0)`.as("total_charges_cents"),
  })
  .from(charges)
  .groupBy(charges.tenantUserId, charges.unitId)

// Build map: `${tenantUserId}:${unitId}` -> totalChargesCents
const chargeMap = new Map(chargeTotals.map(c => [`${c.tenantUserId}:${c.unitId}`, Number(c.totalChargesCents)]))

// 3c. Get all-time succeeded payment totals per tenant-unit pair (for balance)
const paymentTotals = await db
  .select({
    tenantUserId: payments.tenantUserId,
    unitId: payments.unitId,
    totalPaidCents: sql<number>`COALESCE(SUM(${payments.amountCents}), 0)`.as("total_paid_cents"),
  })
  .from(payments)
  .where(eq(payments.status, "succeeded"))
  .groupBy(payments.tenantUserId, payments.unitId)

const totalPaidMap = new Map(paymentTotals.map(p => [`${p.tenantUserId}:${p.unitId}`, Number(p.totalPaidCents)]))
```

Then in the result mapping, add a `balanceCents` field:
```typescript
const key = `${tenantUserId}:${unit.unitId}`
const totalCharges = chargeMap.get(key) ?? 0
const totalPaid = totalPaidMap.get(key) ?? 0
const balanceCents = totalCharges - totalPaid

return {
  ...existingFields,
  balanceCents, // NEW: running balance for this tenant-unit
}
```

2. **Modify the PaymentDashboard component** (find it in `src/components/admin/PaymentDashboard.tsx` or wherever it's defined) to display the new `balanceCents` field.

If the PaymentDashboard is a client component, add a "Balance" column to the table that shows:
- Positive balance: red text "$X.XX owed"
- Zero: green text "Current"
- Negative: blue text "$X.XX credit"

If modifying the admin payments page directly (`src/app/(admin)/admin/payments/page.tsx`), ensure the balance data flows through to the display.

The balance column should appear after the existing payment status column. Use color coding consistent with the tenant BalanceCard (red for owed, green for current, blue for credit).
  </action>
  <verify>
    <automated>npx next build 2>&1 | tail -10</automated>
    Build succeeds. Admin payments page shows balance column with per-tenant amounts.
  </verify>
  <done>
    - Admin payments overview API returns balanceCents for each unit with an active tenant
    - Admin payments page displays per-tenant balance with color coding
    - Balance is computed as SUM(charges) - SUM(succeeded payments), consistent with tenant view
    - Existing period-based payment data still shows correctly
  </done>
</task>

</tasks>

<verification>
- Tenant dashboard shows BalanceCard with computed balance
- If no charges exist yet (pre-backfill), balance shows "$0.00" / "All caught up"
- Admin payments page shows a Balance column for each unit
- Balance computation is consistent: SUM(charges) - SUM(succeeded payments)
</verification>

<success_criteria>
- Tenant dashboard displays "You owe $X" reflecting charges minus payments
- Zero balance shows "All caught up"
- Admin payment dashboard shows per-tenant balance
- Balance computation handles edge cases: no charges, no payments, credits, pending payments
</success_criteria>

<output>
After completion, create `.planning/phases/08-financial-ledger-foundation/08-03-SUMMARY.md`
</output>
