---
phase: 08-financial-ledger-foundation
plan: 04
type: execute
wave: 2
depends_on: [08-01]
files_modified:
  - src/app/api/webhooks/stripe/route.ts
autonomous: true
requirements: [LEDG-05]

must_haves:
  truths:
    - Stripe webhook handler uses event ID deduplication — processing the same event twice has no effect
    - ACH settlement events use strict payment intent ID matching to update payment records
    - Duplicate webhook events do not create duplicate payment records or duplicate charges
    - All webhook processing is wrapped in a transaction for atomicity
  artifacts:
    - src/app/api/webhooks/stripe/route.ts (modified with event dedup + strict PI matching)
  key_links:
    - Webhook handler inserts into stripeEvents table before processing
    - onConflictDoNothing on stripeEvents provides idempotency
    - Payment updates use eq(payments.stripePaymentIntentId, pi.id) for strict matching
---

<objective>
Harden the Stripe webhook handler with event ID deduplication and strict payment intent ID matching.

Purpose: Prevent duplicate ledger entries from Stripe retries and ensure ACH settlements are matched using payment intent IDs rather than session IDs or broad queries. This is LEDG-05.
Output: Modified webhook route with transaction-wrapped dedup and strict PI matching.
</objective>

<execution_context>
@/Users/odesantos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/odesantos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/08-financial-ledger-foundation/08-RESEARCH.md
@.planning/phases/08-financial-ledger-foundation/08-01-SUMMARY.md

<interfaces>
<!-- stripeEvents table from Plan 01 -->
From src/db/schema/domain.ts:
```typescript
export const stripeEvents = pgTable("stripe_events", {
  id: text("id").primaryKey(),
  type: text("type").notNull(),
  processedAt: timestamp("processed_at").defaultNow().notNull(),
})
```

<!-- Current webhook handler -->
From src/app/api/webhooks/stripe/route.ts:
```typescript
// Handles: checkout.session.completed, checkout.session.async_payment_succeeded,
//          checkout.session.async_payment_failed, payment_intent.succeeded, payment_intent.payment_failed
// Current issues:
// 1. No event ID deduplication — relies on onConflictDoNothing (stripeSessionId unique)
// 2. payment_intent.succeeded uses broad match: tenantUserId + unitId + billingPeriod + status
// 3. No transaction wrapping (HTTP driver can't do transactions)
```

<!-- DB module (will be transaction-capable after Phase 7) -->
From src/db/index.ts:
```typescript
export const db = new Proxy({} as NeonHttpDatabase<typeof schema>, { ... })
// After Phase 7: will support db.transaction(async (tx) => { ... })
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add event ID deduplication and strict PI matching to Stripe webhook</name>
  <files>src/app/api/webhooks/stripe/route.ts</files>
  <action>
Rewrite the Stripe webhook handler at `src/app/api/webhooks/stripe/route.ts` with the following changes:

**1. Import stripeEvents table:**
```typescript
import { payments, units, user, stripeEvents } from "@/db/schema"
```

**2. Add event deduplication at the top of the try block (after event parsing):**

After the `switch (event.type)` section is replaced, the overall structure should be:

```typescript
try {
  // EVENT DEDUPLICATION: Check if this event was already processed
  // Use INSERT ... ON CONFLICT DO NOTHING for atomic dedup
  const [inserted] = await db
    .insert(stripeEvents)
    .values({ id: event.id, type: event.type })
    .onConflictDoNothing()
    .returning()

  if (!inserted) {
    // Event already processed — return 200 to acknowledge but don't re-process
    console.log(`Duplicate webhook event skipped: ${event.id} (${event.type})`)
    return NextResponse.json({ received: true, duplicate: true }, { status: 200 })
  }

  // Process event (existing switch statement)
  switch (event.type) {
    // ... cases below
  }
} catch (err) { ... }
```

**IMPORTANT NOTE about transactions:** Phase 7 introduces the WebSocket driver for transaction support. If Phase 7 is NOT yet complete when this plan executes, the dedup above (INSERT ON CONFLICT DO NOTHING + returning check) is still safe — it's a single atomic INSERT. The worst case without a full transaction is that we record the event but fail during processing, meaning a retry will skip the event. This is acceptable (fail-safe: better to miss processing than duplicate). Add a `// TODO: wrap in db.transaction() after Phase 7 WebSocket driver is available` comment if transactions are not yet available.

If Phase 7 IS complete and `db.transaction()` is available, wrap the entire dedup + processing in a transaction:
```typescript
await db.transaction(async (tx) => {
  const [inserted] = await tx.insert(stripeEvents).values({ id: event.id, type: event.type }).onConflictDoNothing().returning()
  if (!inserted) return
  // ... process event using tx instead of db
})
```

**3. Tighten payment_intent.succeeded handler for strict PI matching:**

Replace the current broad match:
```typescript
// OLD: matches on tenantUserId + unitId + billingPeriod + status = "pending"
await db.update(payments).set({ ... }).where(
  and(
    eq(payments.tenantUserId, tenantUserId),
    eq(payments.unitId, unitId),
    eq(payments.billingPeriod, billingPeriod),
    eq(payments.status, "pending")
  )
)
```

With strict payment intent ID matching:
```typescript
// NEW: match on stripePaymentIntentId for precision
await db.update(payments).set({
  status: "succeeded",
  paidAt: new Date(),
  stripePaymentIntentId: paymentIntent.id,
  updatedAt: new Date(),
}).where(
  and(
    eq(payments.stripePaymentIntentId, paymentIntent.id),
    eq(payments.status, "pending")
  )
)
```

This is more precise — it matches the exact payment record created for this payment intent, not any pending payment for the tenant/unit/period.

**4. Tighten payment_intent.payment_failed similarly:**
```typescript
// Match on stripePaymentIntentId instead of broad tenant/unit/period match
await db.update(payments).set({ status: "failed", updatedAt: new Date() }).where(
  and(
    eq(payments.stripePaymentIntentId, paymentIntent.id),
    eq(payments.status, "pending")
  )
)
```

**5. Keep existing checkout.session.* handlers mostly as-is** — they already use `onConflictDoNothing()` on stripeSessionId for idempotency. The event-level dedup adds a second layer of protection.

**6. Keep the sendPaymentConfirmation helper function unchanged** — it's fine as-is.

**Summary of changes:**
- Add stripeEvents import
- Add event ID dedup check at top of processing
- Change payment_intent.succeeded to match on stripePaymentIntentId
- Change payment_intent.payment_failed to match on stripePaymentIntentId
- Add TODO comment for transaction wrapping if Phase 7 not yet complete
  </action>
  <verify>
    <automated>npx tsc --noEmit src/app/api/webhooks/stripe/route.ts 2>&1 | tail -5</automated>
    TypeScript compiles without errors. Webhook handler has event dedup and strict PI matching.
  </verify>
  <done>
    - Stripe webhook inserts event ID into stripe_events before processing
    - Duplicate events (same event.id) are detected and skipped with 200 response
    - payment_intent.succeeded uses stripePaymentIntentId for strict matching
    - payment_intent.payment_failed uses stripePaymentIntentId for strict matching
    - Existing checkout.session.* handlers retain their onConflictDoNothing safety
    - sendPaymentConfirmation helper remains unchanged
  </done>
</task>

</tasks>

<verification>
- Webhook handler compiles without TypeScript errors
- Event dedup logic: first call inserts event + processes, second call with same event ID skips
- payment_intent.succeeded matches on stripePaymentIntentId (not broad tenant/unit/period)
- payment_intent.payment_failed matches on stripePaymentIntentId
- No regression in existing checkout.session handlers
</verification>

<success_criteria>
- Stripe webhook uses strict payment intent ID matching for ACH settlements
- Duplicate webhook events do not create duplicate ledger entries
- Event deduplication is atomic (INSERT ON CONFLICT DO NOTHING)
- All existing payment flows continue to work correctly
</success_criteria>

<output>
After completion, create `.planning/phases/08-financial-ledger-foundation/08-04-SUMMARY.md`
</output>
