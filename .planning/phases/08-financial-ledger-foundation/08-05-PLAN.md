---
phase: 08-financial-ledger-foundation
plan: 05
type: execute
wave: 3
depends_on: [08-01, 08-03, 08-04]
files_modified:
  - scripts/backfill-charges.ts
autonomous: true
requirements: [LEDG-04]

must_haves:
  truths:
    - Every historical payment with status succeeded or pending has a corresponding charge record in the charges table
    - Running the backfill script twice does not create duplicate charge records
    - After backfill, tenant balances accurately reflect their financial history
    - The backfill script supports a dry-run mode that reports what would be created without modifying data
  artifacts:
    - scripts/backfill-charges.ts (idempotent backfill migration script)
  key_links:
    - Script creates rent charges matching each historical payment's billing period and amount
    - Uses units.rentAmountCents for charge amount when available, falls back to payment amount
    - Dedup check prevents duplicate charges for same tenant + unit + billingPeriod + type
---

<objective>
Create and run an idempotent backfill script that reconciles historical payment records with corresponding charge records.

Purpose: All existing payments from v1.0 need corresponding charge records so that balance computation (charges - payments) is accurate. Without this, tenants with historical payments would show zero balance because there are no charges. This is LEDG-04.
Output: Backfill script that creates rent charge records for all historical payments.
</objective>

<execution_context>
@/Users/odesantos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/odesantos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/08-financial-ledger-foundation/08-RESEARCH.md
@.planning/phases/08-financial-ledger-foundation/08-01-SUMMARY.md

<interfaces>
<!-- Payments table (existing data to reconcile) -->
From src/db/schema/domain.ts:
```typescript
export const payments = pgTable("payments", {
  id: uuid("id").primaryKey().defaultRandom(),
  tenantUserId: text("tenant_user_id").notNull(),
  unitId: uuid("unit_id").references(() => units.id).notNull(),
  amountCents: integer("amount_cents").notNull(),
  paymentMethod: text("payment_method", { enum: ["card", "ach", "cash", "check", "venmo", "other"] }).notNull(),
  status: text("status", { enum: ["pending", "succeeded", "failed"] }).notNull(),
  billingPeriod: text("billing_period").notNull(), // "2026-03"
  note: text("note"),
  paidAt: timestamp("paid_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
})
```

<!-- Charges table (target for backfill) -->
From src/db/schema/domain.ts (after Plan 01):
```typescript
export const charges = pgTable("charges", {
  id: uuid("id").primaryKey().defaultRandom(),
  tenantUserId: text("tenant_user_id").notNull(),
  unitId: uuid("unit_id").references(() => units.id).notNull(),
  type: text("type", { enum: ["rent", "late_fee", "one_time", "credit", "adjustment"] }).notNull(),
  description: text("description").notNull(),
  amountCents: integer("amount_cents").notNull(),
  billingPeriod: text("billing_period"),
  createdBy: text("created_by"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
})
```

<!-- Units table for rent amount lookup -->
From src/db/schema/domain.ts:
```typescript
export const units = pgTable("units", {
  id: uuid("id").primaryKey().defaultRandom(),
  rentAmountCents: integer("rent_amount_cents"),
  // ...
})
```

<!-- Existing script patterns -->
From package.json:
```json
"seed:admin": "tsx -r tsconfig-paths/register scripts/seed-admin.ts"
```

<!-- dotenv convention from MEMORY.md -->
// Must use: config({ path: ".env.local" })
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create idempotent backfill migration script</name>
  <files>scripts/backfill-charges.ts</files>
  <action>
Create `scripts/backfill-charges.ts` — an idempotent script that creates charge records for all historical payments.

**IMPORTANT:** Use `config({ path: ".env.local" })` for dotenv (project convention from MEMORY.md). Use `tsx -r tsconfig-paths/register` for running (matching existing seed script pattern).

**Script structure:**

```typescript
import { config } from "dotenv"
config({ path: ".env.local" })

import { neon } from "@neondatabase/serverless"
import { drizzle } from "drizzle-orm/neon-http"
import * as schema from "../src/db/schema"
import { eq, and, inArray, sql } from "drizzle-orm"

const { payments, charges, units } = schema

// Create a standalone DB connection (not the lazy-proxy from src/db/index.ts)
const sql_client = neon(process.env.DATABASE_URL!)
const db = drizzle({ client: sql_client, schema })

const isDryRun = process.argv.includes("--dry-run")

async function backfill() {
  console.log(`\n=== Charge Backfill Migration ${isDryRun ? "(DRY RUN)" : ""} ===\n`)

  // 1. Count existing state
  const [paymentCount] = await db.select({ count: sql<number>`COUNT(*)` }).from(payments)
    .where(inArray(payments.status, ["succeeded", "pending"]))
  const [chargeCount] = await db.select({ count: sql<number>`COUNT(*)` }).from(charges)

  console.log(`Existing payments (succeeded/pending): ${paymentCount.count}`)
  console.log(`Existing charges: ${chargeCount.count}`)

  // 2. Get all succeeded/pending payments
  const historicalPayments = await db
    .select()
    .from(payments)
    .where(inArray(payments.status, ["succeeded", "pending"]))
    .orderBy(payments.createdAt)

  // 3. Get unit rent amounts for charge amount determination
  const allUnits = await db.select({ id: units.id, rentAmountCents: units.rentAmountCents }).from(units)
  const unitRentMap = new Map(allUnits.map(u => [u.id, u.rentAmountCents]))

  // 4. Get existing charges to check for duplicates (idempotency)
  const existingCharges = await db
    .select({
      tenantUserId: charges.tenantUserId,
      unitId: charges.unitId,
      billingPeriod: charges.billingPeriod,
      type: charges.type,
    })
    .from(charges)
    .where(eq(charges.type, "rent"))

  // Build dedup set: "tenantUserId:unitId:billingPeriod"
  const existingChargeKeys = new Set(
    existingCharges.map(c => `${c.tenantUserId}:${c.unitId}:${c.billingPeriod}`)
  )

  // 5. Determine which charges need to be created
  // Group payments by tenant + unit + billing period to create ONE charge per period
  const chargeMap = new Map<string, {
    tenantUserId: string
    unitId: string
    billingPeriod: string
    totalPaymentCents: number
  }>()

  for (const payment of historicalPayments) {
    const key = `${payment.tenantUserId}:${payment.unitId}:${payment.billingPeriod}`

    if (existingChargeKeys.has(key)) continue // Already has a charge

    if (!chargeMap.has(key)) {
      chargeMap.set(key, {
        tenantUserId: payment.tenantUserId,
        unitId: payment.unitId,
        billingPeriod: payment.billingPeriod,
        totalPaymentCents: payment.amountCents,
      })
    } else {
      // Multiple payments for same period — use the larger amount for the charge
      const existing = chargeMap.get(key)!
      existing.totalPaymentCents = Math.max(existing.totalPaymentCents, payment.amountCents)
    }
  }

  // 6. Create charges
  const chargesToCreate = Array.from(chargeMap.values())
  console.log(`\nCharges to create: ${chargesToCreate.length}`)

  if (chargesToCreate.length === 0) {
    console.log("No new charges needed — all payments already have corresponding charges.")
    return
  }

  let created = 0
  let skipped = 0

  for (const chargeData of chargesToCreate) {
    // Use unit rent amount if available, otherwise use payment amount
    const unitRent = unitRentMap.get(chargeData.unitId)
    const chargeAmountCents = unitRent ?? chargeData.totalPaymentCents

    const chargeValues = {
      tenantUserId: chargeData.tenantUserId,
      unitId: chargeData.unitId,
      type: "rent" as const,
      description: `Rent for ${chargeData.billingPeriod}`,
      amountCents: chargeAmountCents,
      billingPeriod: chargeData.billingPeriod,
      createdBy: null, // system-generated backfill
    }

    if (isDryRun) {
      console.log(`  [DRY RUN] Would create charge: tenant=${chargeData.tenantUserId.slice(0,8)}... unit=${chargeData.unitId.slice(0,8)}... period=${chargeData.billingPeriod} amount=$${(chargeAmountCents / 100).toFixed(2)}`)
      created++
    } else {
      try {
        await db.insert(charges).values(chargeValues)
        created++
      } catch (err) {
        console.error(`  Error creating charge for ${chargeData.billingPeriod}:`, err)
        skipped++
      }
    }
  }

  console.log(`\n=== Results ===`)
  console.log(`Created: ${created}`)
  console.log(`Skipped/Errored: ${skipped}`)
  console.log(`Total charges after: ${Number(chargeCount.count) + created}`)

  // 7. Validation: verify balance sanity
  if (!isDryRun) {
    console.log(`\n=== Post-Backfill Validation ===`)
    const [newChargeCount] = await db.select({ count: sql<number>`COUNT(*)` }).from(charges)
    console.log(`Total charges in DB: ${newChargeCount.count}`)

    // Check for any payments without corresponding charges
    const orphaned = await db.execute(sql`
      SELECT COUNT(DISTINCT CONCAT(tenant_user_id, ':', unit_id, ':', billing_period))
      FROM payments
      WHERE status IN ('succeeded', 'pending')
      AND CONCAT(tenant_user_id, ':', unit_id, ':', billing_period) NOT IN (
        SELECT CONCAT(tenant_user_id, ':', unit_id, ':', billing_period)
        FROM charges
        WHERE type = 'rent'
      )
    `)
    console.log(`Payments without matching charges: ${JSON.stringify(orphaned[0])}`)
  }

  console.log(`\nBackfill ${isDryRun ? "dry run " : ""}complete.`)
}

backfill().catch(console.error)
```

**Add a script entry to package.json:**
```json
"backfill:charges": "tsx -r tsconfig-paths/register scripts/backfill-charges.ts"
```

**Then run the script:**
1. First with `--dry-run` to verify what will be created: `npm run backfill:charges -- --dry-run`
2. Then for real: `npm run backfill:charges`
3. Run again to verify idempotency: `npm run backfill:charges` (should report "No new charges needed")

**Key design decisions:**
- One charge per tenant-unit-period combination (not per payment — a tenant might have multiple payments for the same period, e.g., a partial payment + completion)
- Use units.rentAmountCents for charge amount when available (represents the actual obligation). Fall back to payment amount for units where rent wasn't configured.
- Credits stored as negative amountCents: NOT applicable here — all backfilled charges are positive rent charges.
- System-generated: createdBy is null to distinguish from admin-posted charges.
  </action>
  <verify>
    <automated>tsx -r tsconfig-paths/register scripts/backfill-charges.ts --dry-run 2>&1 | tail -10</automated>
    Dry run completes without errors and reports the number of charges that would be created. Running the real script and then running it again shows "No new charges needed" (idempotency verified).
  </verify>
  <done>
    - scripts/backfill-charges.ts exists and runs successfully
    - --dry-run mode reports what would be created without modifying data
    - Running the script creates one rent charge per unique tenant-unit-period combination
    - Running the script twice produces no duplicates (idempotent)
    - Post-backfill validation reports no orphaned payments
    - package.json has a "backfill:charges" script entry
    - After backfill, getTenantBalance returns accurate balances for historical tenants
  </done>
</task>

</tasks>

<verification>
- Dry run reports expected charge count matching historical payment distribution
- Real run creates charge records and validation passes
- Second run reports "No new charges needed"
- After backfill, navigating to tenant dashboard shows accurate balance (not $0.00 when payments exist)
- Admin payments overview shows accurate per-tenant balances
</verification>

<success_criteria>
- All historical payment records from v1.0 have been reconciled with corresponding charge records
- Backfill is idempotent — safe to run multiple times
- Backfill uses unit rent amount for charge amount (falling back to payment amount)
- After backfill, tenant and admin balance views are accurate
</success_criteria>

<output>
After completion, create `.planning/phases/08-financial-ledger-foundation/08-05-SUMMARY.md`
</output>
