---
phase: 08-financial-ledger-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema/domain.ts
  - src/db/schema/index.ts
  - drizzle/0005_*.sql
  - src/lib/ledger.ts
  - e2e/ledger.spec.ts
autonomous: true
requirements: [LEDG-01, LEDG-02]

must_haves:
  truths:
    - A charges table exists in the database with columns for tenant, unit, type, description, amountCents, and billingPeriod
    - A stripeEvents table exists for webhook event deduplication
    - A getTenantBalance helper function computes balance as SUM(charges) - SUM(succeeded payments)
    - An e2e test scaffold file exists for ledger tests
  artifacts:
    - src/db/schema/domain.ts (charges + stripeEvents table definitions)
    - src/lib/ledger.ts (balance computation helper)
    - e2e/ledger.spec.ts (test scaffold)
  key_links:
    - charges table references units.id with onDelete restrict
    - charges.type enum includes rent, late_fee, one_time, credit, adjustment
    - getTenantBalance returns a number (balance in cents)
---

<objective>
Create the charges and stripe_events database tables and the balance computation helper.

Purpose: Establish the core ledger data model that separates charges (what is owed) from payments (what was paid), and provide a reusable function for computing running balances. This is the foundation all other Phase 8 plans build upon.
Output: New database tables via Drizzle schema + migration, balance helper function, e2e test scaffold.
</objective>

<execution_context>
@/Users/odesantos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/odesantos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/08-financial-ledger-foundation/08-RESEARCH.md

<interfaces>
<!-- Existing schema pattern from src/db/schema/domain.ts -->
From src/db/schema/domain.ts:
```typescript
import { pgTable, text, integer, boolean, timestamp, uuid } from "drizzle-orm/pg-core"

export const units = pgTable("units", {
  id: uuid("id").primaryKey().defaultRandom(),
  propertyId: uuid("property_id").references(() => properties.id, { onDelete: "cascade" }).notNull(),
  unitNumber: text("unit_number").notNull(),
  rentAmountCents: integer("rent_amount_cents"),
  rentDueDay: integer("rent_due_day"),
  // ...
})

export const payments = pgTable("payments", {
  id: uuid("id").primaryKey().defaultRandom(),
  tenantUserId: text("tenant_user_id").notNull(),
  unitId: uuid("unit_id").references(() => units.id, { onDelete: "cascade" }).notNull(),
  amountCents: integer("amount_cents").notNull(),
  stripeSessionId: text("stripe_session_id").unique(),
  stripePaymentIntentId: text("stripe_payment_intent_id"),
  paymentMethod: text("payment_method", { enum: ["card", "ach", "cash", "check", "venmo", "other"] }).notNull(),
  status: text("status", { enum: ["pending", "succeeded", "failed"] }).notNull(),
  billingPeriod: text("billing_period").notNull(),
  note: text("note"),
  paidAt: timestamp("paid_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
})
```

From src/db/index.ts:
```typescript
// Uses Neon HTTP driver currently — Phase 7 will swap to WebSocket for transactions
import { neon } from "@neondatabase/serverless"
import { drizzle, NeonHttpDatabase } from "drizzle-orm/neon-http"
export const db = new Proxy({} as NeonHttpDatabase<typeof schema>, { ... })
```

From drizzle.config.ts:
```typescript
import { config } from "dotenv"
config({ path: ".env.local" })
import { defineConfig } from "drizzle-kit"
export default defineConfig({
  out: "./drizzle",
  schema: "./src/db/schema",
  dialect: "postgresql",
  dbCredentials: { url: process.env.DATABASE_URL! },
})
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add charges and stripeEvents tables to Drizzle schema</name>
  <files>src/db/schema/domain.ts</files>
  <action>
Add two new table definitions to src/db/schema/domain.ts after the autopayEnrollments table:

1. **charges table** — append-only ledger of financial obligations:
   - `id`: uuid, primaryKey, defaultRandom
   - `tenantUserId`: text, notNull (Better Auth user.id — text type, NOT uuid)
   - `unitId`: uuid, references units.id with onDelete "restrict" (NOT cascade — protects financial history; Phase 7 changes cascades but if not done yet, use "cascade" and add a TODO comment). notNull
   - `type`: text enum ["rent", "late_fee", "one_time", "credit", "adjustment"], notNull
   - `description`: text, notNull (e.g., "Rent for 2026-03", "Late fee", "Parking fee")
   - `amountCents`: integer, notNull (positive = charge/debit, negative = credit/adjustment that reduces balance)
   - `billingPeriod`: text, nullable (YYYY-MM format for rent charges, null for one-time charges)
   - `createdBy`: text, nullable (admin user ID for manual entries, null for system-generated)
   - `createdAt`: timestamp, defaultNow, notNull

2. **stripeEvents table** — webhook event deduplication:
   - `id`: text, primaryKey (Stripe event ID like "evt_xxx" — NOT uuid, use text)
   - `type`: text, notNull (Stripe event type string like "payment_intent.succeeded")
   - `processedAt`: timestamp, defaultNow, notNull

Add a section comment: `// ==================== Phase 8: Financial Ledger ====================`

Export both tables. They will be automatically re-exported via src/db/schema/index.ts (which does `export * from "./domain"`).

After adding the schema, run: `npx drizzle-kit generate` to create the migration SQL file, then `npx drizzle-kit push` to apply the schema to the database.

IMPORTANT: The onDelete for unitId on charges should ideally be "restrict" (Phase 7 requirement), but if Phase 7 hasn't changed the existing cascade behavior yet, use "cascade" with a `// TODO: change to restrict after Phase 7 INFRA-05` comment to avoid migration conflicts. Check existing units FK patterns for consistency.
  </action>
  <verify>
    <automated>npx drizzle-kit push --force 2>&1 | tail -5</automated>
    Run `npx drizzle-kit push` — should apply without errors. Verify the charges and stripe_events tables exist in the database.
  </verify>
  <done>
    - charges table exists in database with all specified columns and correct types
    - stripe_events table exists in database with text primary key for Stripe event IDs
    - Both tables exported from src/db/schema/domain.ts
    - Drizzle migration file generated in drizzle/ directory
  </done>
</task>

<task type="auto">
  <name>Task 2: Create balance computation helper and e2e test scaffold</name>
  <files>src/lib/ledger.ts, e2e/ledger.spec.ts</files>
  <action>
1. **Create src/lib/ledger.ts** with balance computation helpers:

```typescript
import { db } from "@/db"
import { charges, payments } from "@/db/schema"
import { eq, and, sql } from "drizzle-orm"

/**
 * Compute the running balance for a tenant's unit.
 * Balance = SUM(charges.amountCents) - SUM(succeeded payments.amountCents)
 * Positive = tenant owes money. Zero = all caught up. Negative = tenant has credit.
 */
export async function getTenantBalance(
  tenantUserId: string,
  unitId: string
): Promise<number> {
  const [result] = await db.execute(sql`
    SELECT
      COALESCE(
        (SELECT SUM(amount_cents) FROM charges
         WHERE tenant_user_id = ${tenantUserId} AND unit_id = ${unitId}),
        0
      )
      -
      COALESCE(
        (SELECT SUM(amount_cents) FROM payments
         WHERE tenant_user_id = ${tenantUserId} AND unit_id = ${unitId}
         AND status = 'succeeded'),
        0
      )
      AS balance_cents
  `)
  return Number((result as { balance_cents: string })?.balance_cents ?? 0)
}

/**
 * Format balance for display.
 * Returns { text: string, status: "owed" | "credit" | "current" }
 */
export function formatBalance(balanceCents: number): {
  text: string
  status: "owed" | "credit" | "current"
} {
  if (balanceCents > 0) {
    return {
      text: `$${(balanceCents / 100).toFixed(2)}`,
      status: "owed",
    }
  } else if (balanceCents < 0) {
    return {
      text: `$${(Math.abs(balanceCents) / 100).toFixed(2)}`,
      status: "credit",
    }
  }
  return { text: "$0.00", status: "current" }
}
```

2. **Create e2e/ledger.spec.ts** with a test scaffold for Phase 8 validation:

```typescript
import { test, expect } from "@playwright/test"

test.describe("Financial Ledger", () => {
  // LEDG-01: Charges table separates what is owed from what was paid
  test.describe("charge creation", () => {
    test.skip("charges table stores financial obligations separately from payments", async ({ page }) => {
      // Will be implemented when admin charge UI is ready
    })
  })

  // LEDG-02: Running balance displayed on tenant dashboard and admin views
  test.describe("running balance", () => {
    test.skip("tenant dashboard displays computed running balance", async ({ page }) => {
      // Will verify balance display after UI integration
    })

    test.skip("admin view shows per-tenant balance", async ({ page }) => {
      // Will verify admin balance display after UI integration
    })
  })

  // LEDG-03: Admin can post charges, credits, and adjustments
  test.describe("admin charge management", () => {
    test.skip("admin can post a charge to a tenant ledger", async ({ page }) => {
      // Will test admin charge form
    })

    test.skip("admin can post a credit to a tenant ledger", async ({ page }) => {
      // Will test admin credit posting
    })
  })

  // LEDG-05: Webhook deduplication
  test.describe("webhook dedup", () => {
    test.skip("duplicate stripe events do not create duplicate ledger entries", async ({ page }) => {
      // Will test webhook idempotency
    })
  })
})
```

The scaffold uses `test.skip` for tests that will be unskipped as features are implemented in subsequent plans.
  </action>
  <verify>
    <automated>npx playwright test e2e/ledger.spec.ts --list 2>&1 | head -20</automated>
    The test file should be parseable and list the skipped tests without errors.
  </verify>
  <done>
    - src/lib/ledger.ts exists with getTenantBalance and formatBalance functions
    - e2e/ledger.spec.ts exists with test scaffolds for LEDG-01, LEDG-02, LEDG-03, LEDG-05
    - getTenantBalance correctly computes SUM(charges) - SUM(succeeded payments)
    - formatBalance correctly handles positive (owed), negative (credit), and zero (current) balances
  </done>
</task>

</tasks>

<verification>
- charges and stripe_events tables exist in the database schema
- src/lib/ledger.ts exports getTenantBalance and formatBalance
- e2e/ledger.spec.ts lists tests without parse errors
- No existing tests broken by schema additions
</verification>

<success_criteria>
- The charges table exists and can store charge records with type, description, amountCents, and billingPeriod
- The stripe_events table exists for webhook event deduplication
- getTenantBalance computes balance = SUM(charges) - SUM(succeeded_payments)
- formatBalance returns appropriate display strings for owed/credit/current states
- E2E test scaffold ready for subsequent plans to unskip
</success_criteria>

<output>
After completion, create `.planning/phases/08-financial-ledger-foundation/08-01-SUMMARY.md`
</output>
