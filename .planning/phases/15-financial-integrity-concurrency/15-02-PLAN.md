---
phase: 15-financial-integrity-concurrency
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/app/api/webhooks/stripe/route.ts
  - src/lib/__tests__/webhook-upsert.test.ts
autonomous: true
requirements: [HARD-02]

must_haves:
  truths:
    - "When async_payment_succeeded arrives before checkout.session.completed, the payment record is created via INSERT (not lost by a no-match UPDATE)"
    - "When async_payment_succeeded arrives after checkout.session.completed, the existing pending payment is updated to succeeded via ON CONFLICT UPDATE"
    - "When the same webhook event is delivered multiple times, no duplicate payment records or ledger entries are created"
    - "When async_payment_failed arrives before checkout.session.completed, the payment record is created with status=failed (not lost)"
  artifacts:
    - path: "src/app/api/webhooks/stripe/route.ts"
      provides: "UPSERT-based webhook handlers for ACH events"
      contains: "onConflictDoUpdate"
    - path: "src/lib/__tests__/webhook-upsert.test.ts"
      provides: "Unit tests proving UPSERT logic handles out-of-order delivery"
  key_links:
    - from: "src/app/api/webhooks/stripe/route.ts"
      to: "payments table"
      via: "INSERT ... ON CONFLICT (stripe_session_id) DO UPDATE"
      pattern: "onConflictDoUpdate"
---

<objective>
Fix Stripe webhook handlers for ACH async events to use UPSERT instead of UPDATE, so out-of-order webhook delivery does not permanently trap payments in "pending" status.

Purpose: ACH payments take 3-5 business days to settle. Stripe may deliver `checkout.session.async_payment_succeeded` before `checkout.session.completed` finishes processing (race condition). The current UPDATE-only approach silently fails when the payment record doesn't exist yet, leaving the payment stuck in "pending" forever.

Output: Modified webhook route using INSERT ... ON CONFLICT DO UPDATE for async events, with unit tests proving correctness.
</objective>

<execution_context>
@/Users/odesantos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/odesantos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@src/app/api/webhooks/stripe/route.ts
@src/db/schema/domain.ts

<interfaces>
From src/db/schema/domain.ts — payments table:
```typescript
export const payments = pgTable("payments", {
  id: uuid("id").primaryKey().defaultRandom(),
  tenantUserId: text("tenant_user_id").notNull(),
  unitId: uuid("unit_id").references(() => units.id, { onDelete: "restrict" }).notNull(),
  amountCents: integer("amount_cents").notNull(),
  stripeSessionId: text("stripe_session_id").unique(),  // <-- UNIQUE constraint enables ON CONFLICT
  stripePaymentIntentId: text("stripe_payment_intent_id"),
  paymentMethod: text("payment_method", { enum: ["card", "ach", "cash", "check", "venmo", "other"] }).notNull(),
  status: text("status", { enum: ["pending", "succeeded", "failed"] }).notNull(),
  billingPeriod: text("billing_period").notNull(),
  note: text("note"),
  paidAt: timestamp("paid_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
})
```

Key detail: `stripeSessionId` has a UNIQUE constraint — this is the conflict target for the UPSERT.
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Write tests describing expected UPSERT behavior for out-of-order webhooks</name>
  <files>src/lib/__tests__/webhook-upsert.test.ts</files>
  <behavior>
    - Test: "async_payment_succeeded before completed — should INSERT new payment with status succeeded" — verifies that when no payment record exists, the UPSERT creates one
    - Test: "async_payment_succeeded after completed — should UPDATE existing pending payment to succeeded" — verifies the normal flow still works
    - Test: "async_payment_failed before completed — should INSERT new payment with status failed" — verifies failed path also handles out-of-order
    - Test: "async_payment_failed after completed — should UPDATE existing pending payment to failed" — normal fail flow
    - Test: "duplicate async_payment_succeeded — second call is idempotent via event dedup" — verifies stripe_events dedup prevents reprocessing
  </behavior>
  <action>
    Create `src/lib/__tests__/webhook-upsert.test.ts`. Since the webhook handler is tightly coupled to HTTP request/response and Stripe signature verification, test the UPSERT logic by extracting the key decision into a descriptive test suite. The tests should describe the EXPECTED Drizzle ORM call pattern, not mock the full database.

    Approach: Create a pure function `buildAchPaymentUpsert` that returns the values object for the UPSERT. Test it returns correct values for each scenario. The function signature:

    ```typescript
    interface AchPaymentUpsertValues {
      tenantUserId: string
      unitId: string
      amountCents: number
      stripeSessionId: string
      stripePaymentIntentId: string | null
      paymentMethod: "ach"
      status: "succeeded" | "failed"
      billingPeriod: string
      paidAt: Date | null
    }

    function buildAchPaymentUpsert(
      session: { id: string; amount_total: number; payment_intent: string | null },
      metadata: { tenantUserId: string; unitId: string; billingPeriod: string },
      status: "succeeded" | "failed"
    ): AchPaymentUpsertValues
    ```

    Tests verify:
    - Correct status mapping (succeeded vs failed)
    - paidAt is set for succeeded, null for failed
    - All required fields are populated from session metadata
    - amountCents comes from session.amount_total

    Use vitest. Import pattern: `import { describe, it, expect } from "vitest"`.
  </action>
  <verify>
    <automated>npx vitest run src/lib/__tests__/webhook-upsert.test.ts 2>&1 | tail -20</automated>
  </verify>
  <done>Test file exists with 5 test cases describing correct UPSERT behavior for out-of-order ACH webhooks</done>
</task>

<task type="auto" tdd="true">
  <name>Task 2: Convert async webhook handlers from UPDATE to UPSERT</name>
  <files>src/app/api/webhooks/stripe/route.ts, src/lib/__tests__/webhook-upsert.test.ts</files>
  <behavior>
    - buildAchPaymentUpsert for succeeded returns { status: "succeeded", paidAt: Date, paymentMethod: "ach" }
    - buildAchPaymentUpsert for failed returns { status: "failed", paidAt: null, paymentMethod: "ach" }
  </behavior>
  <action>
    **GREEN phase:** Make tests pass and fix the webhook handler.

    1. **Define `buildAchPaymentUpsert`** — either inline in the test file (since it's trivial) or export from a small helper. Simplest: define it in the test file and verify the production code uses the equivalent logic.

    2. **Modify `src/app/api/webhooks/stripe/route.ts`** — replace the `checkout.session.async_payment_succeeded` handler (lines 105-128) with UPSERT:

    ```typescript
    case "checkout.session.async_payment_succeeded": {
      const session = event.data.object as Stripe.Checkout.Session
      const { tenantUserId, unitId, billingPeriod } = session.metadata || {}

      if (!tenantUserId || !unitId || !billingPeriod) {
        console.error("Missing metadata in async_payment_succeeded:", session.id)
        break
      }

      // UPSERT: INSERT if checkout.session.completed hasn't created the record yet,
      // or UPDATE if it has (normal flow). Handles out-of-order webhook delivery.
      await tx
        .insert(payments)
        .values({
          tenantUserId,
          unitId,
          amountCents: session.amount_total!,
          stripeSessionId: session.id,
          stripePaymentIntentId: session.payment_intent as string,
          paymentMethod: "ach",
          status: "succeeded",
          billingPeriod,
          paidAt: new Date(),
        })
        .onConflictDoUpdate({
          target: payments.stripeSessionId,
          set: {
            status: "succeeded",
            paidAt: new Date(),
            updatedAt: new Date(),
          },
        })

      await sendPaymentConfirmation(tenantUserId, unitId, session.amount_total!, billingPeriod)
      break
    }
    ```

    3. **Replace the `checkout.session.async_payment_failed` handler** (lines 131-145) with UPSERT:

    ```typescript
    case "checkout.session.async_payment_failed": {
      const session = event.data.object as Stripe.Checkout.Session
      const { tenantUserId, unitId, billingPeriod } = session.metadata || {}

      if (!tenantUserId || !unitId || !billingPeriod) {
        console.error("Missing metadata in async_payment_failed:", session.id)
        break
      }

      // UPSERT: INSERT if completed hasn't run yet, or UPDATE if it has.
      await tx
        .insert(payments)
        .values({
          tenantUserId,
          unitId,
          amountCents: session.amount_total!,
          stripeSessionId: session.id,
          stripePaymentIntentId: session.payment_intent as string,
          paymentMethod: "ach",
          status: "failed",
          billingPeriod,
        })
        .onConflictDoUpdate({
          target: payments.stripeSessionId,
          set: {
            status: "failed",
            updatedAt: new Date(),
          },
        })

      // Post NSF fee
      if (tenantUserId && unitId) {
        await postNsfFee(tx, tenantUserId, unitId, billingPeriod)
      }
      break
    }
    ```

    4. **Key changes from UPDATE to UPSERT:**
       - Added metadata validation (was missing in async handlers — the metadata destructuring happened but was only used conditionally)
       - INSERT provides ALL required fields (tenantUserId, unitId, amountCents, etc.) so the record can be created from scratch
       - ON CONFLICT targets `stripeSessionId` (which has a UNIQUE constraint in the schema)
       - ON CONFLICT SET only updates status-related fields (not the immutable fields like tenantUserId, unitId, amountCents)

    5. **Idempotency note:** The stripe_events table deduplication (lines 36-44) already prevents the same event from being processed twice. The UPSERT is a second layer of defense — even if event dedup fails, the UPSERT won't create duplicates because of the stripeSessionId UNIQUE constraint.

    Run tests — they should now PASS.
  </action>
  <verify>
    <automated>npx vitest run src/lib/__tests__/webhook-upsert.test.ts 2>&1 | tail -20</automated>
  </verify>
  <done>Webhook handlers for async_payment_succeeded and async_payment_failed use UPSERT (INSERT ... ON CONFLICT DO UPDATE) instead of UPDATE. All tests pass. Out-of-order webhook delivery cannot permanently trap payments in "pending" status.</done>
</task>

</tasks>

<verification>
1. `npx vitest run src/lib/__tests__/webhook-upsert.test.ts` — all tests pass
2. `grep -n "onConflictDoUpdate" src/app/api/webhooks/stripe/route.ts` — confirms UPSERT is used (should appear twice: once for succeeded, once for failed)
3. `grep -n "\.update(payments)" src/app/api/webhooks/stripe/route.ts` — the checkout.session.async_* handlers should NOT use bare UPDATE anymore (payment_intent handlers for autopay still use update, which is fine since they match on stripePaymentIntentId)
4. `npx tsc --noEmit` — TypeScript compiles without errors
</verification>

<success_criteria>
- checkout.session.async_payment_succeeded uses UPSERT (INSERT ... ON CONFLICT DO UPDATE on stripeSessionId)
- checkout.session.async_payment_failed uses UPSERT with same pattern
- Out-of-order delivery (async event before completed) creates the payment record instead of silently failing
- Normal-order delivery (async event after completed) updates the existing record
- Duplicate event delivery is handled by both stripe_events dedup AND stripeSessionId UNIQUE constraint
- NSF fee posting is preserved for failed payments
- Payment confirmation email is preserved for succeeded payments
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/15-financial-integrity-concurrency/15-02-SUMMARY.md`
</output>
